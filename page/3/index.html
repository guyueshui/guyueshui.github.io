<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>水阙</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Yychi"><meta name=description content="向往水的温柔，在心底打着卷儿。"><meta name=keywords content="水阙,yychi"><meta name=generator content="Hugo 0.112.3 with theme even"><link rel=canonical href=https://guyueshui.github.io/><link href=https://guyueshui.github.io/index.xml rel=alternate type=application/rss+xml title=水阙><link href=https://guyueshui.github.io/index.xml rel=feed type=application/rss+xml title=水阙><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.4db6eefa019323deeb0f96ac97b0195c6875d5cb6a98e30c1e245d54b43d54bc.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=/css/even-custom.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&family=Noto+Serif+SC:wght@400;500;700&display=swap" rel=stylesheet><meta property="og:title" content="水阙"><meta property="og:description" content="向往水的温柔，在心底打着卷儿。"><meta property="og:type" content="website"><meta property="og:url" content="https://guyueshui.github.io/"><meta itemprop=name content="水阙"><meta itemprop=description content="向往水的温柔，在心底打着卷儿。"><meta name=twitter:card content="summary"><meta name=twitter:title content="水阙"><meta name=twitter:description content="向往水的温柔，在心底打着卷儿。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Yychi's Blog</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/search/><li class=mobile-menu-item>Search</li></a><a href=/links/><li class=mobile-menu-item>More</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tricks/><li class=mobile-menu-item>Tricks</li></a><a href=/sketch/><li class=mobile-menu-item>Sketch</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Yychi's Blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/search/>Search</a></li><li class=menu-item><a class=menu-item-link href=/links/>More</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tricks/>Tricks</a></li><li class=menu-item><a class=menu-item-link href=/sketch/>Sketch</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><section id=posts class=posts><article class=post><header class=post-header><h1 class=post-title><a class=post-link href=/post/what-is-escape-character/>转义字符到底是什么</a></h1><div class=post-meta><span class=post-time>March 18, 2020</span><div class=post-category><a href=/categories/notes/>Notes</a></div></div></header><div class=post-content><div class=post-summary>转义字符到底是啥？ 实不相瞒我就是因为不知道才写下这篇文章，不，准确的说是这篇笔记orz，既然是笔记，无所谓抄不抄了。每次说到转义字符，多少有</div><div class=read-more><a href=/post/what-is-escape-character/ class=read-more-link>Read more...</a></div></div></article><article class=post><header class=post-header><h1 class=post-title><a class=post-link href=/post/nice-softwares/>小内存机器的自我救赎</a></h1><div class=post-meta><span class=post-time>March 12, 2020</span></div></header><div class=post-content><div class=post-summary>在此记录一下我自己用过的非常棒的小软件。 下载 aria2c: 命令行下载工具，支持下载种子、磁力等。有RPC模式，配合WebUI使用更佳。参考简介。 多媒体 mpv:</div><div class=read-more><a href=/post/nice-softwares/ class=read-more-link>Read more...</a></div></div></article><article class=post><header class=post-header><h1 class=post-title><a class=post-link href=/post/shell-intro/>Brief Introduction to Shell Script</a></h1><div class=post-meta><span class=post-time>November 22, 2019</span><div class=post-category><a href=/categories/notes/>Notes</a></div></div></header><div class=post-content><div class=post-summary>This article is mainly refered to &ldquo;The Linux Command Line&rdquo;1. I just take some most important things out of the book.
Expansion Each time you type a command line and press the Enter key, bash performs several processes upon the text before it carries out your command. Just look an example:
1 2 [me@linuxbox ~]$ echo * Desktop Documents ls-output.txt Music Pictures Public Templates Videos Why not display an asterisk? That&rsquo;s expansion!</div><div class=read-more><a href=/post/shell-intro/ class=read-more-link>Read more...</a></div></div></article><article class=post><header class=post-header><h1 class=post-title><a class=post-link href=/post/nn-notes/>Nueral Network Learning Notes</a></h1><div class=post-meta><span class=post-time>October 29, 2019</span><div class=post-category><a href=/categories/notes/>notes</a></div></div></header><div class=post-content><div class=post-summary>Hello here.
CNN Conv Layer Conv Layer is usually decreasing the input size, i.e., the output size may less or equal than input.
take a volume as input: height x weight x depth, e.g., 32x32x3. Typically think an image having three channels: R, G, B. a filter has the same depth as the input volume, e.g., 5x5x3 (since the filter always has a same depth as input vloume, the depth of the filter is sometimes omitted).</div><div class=read-more><a href=/post/nn-notes/ class=read-more-link>Read more...</a></div></div></article><article class=post><header class=post-header><h1 class=post-title><a class=post-link href=/post/server-develop-preliminaries/>服务端开发预备知识</a></h1><div class=post-meta><span class=post-time>September 6, 2019</span><div class=post-category><a href=/categories/notes/>Notes</a></div></div></header><div class=post-content><div class=post-summary>操作系统 摘自《程序员面试白皮书》 进程vs.线程 进程（process）与线程（thread）最大的区别是进程拥有自己的地址空间，某进程内的线程</div><div class=read-more><a href=/post/server-develop-preliminaries/ class=read-more-link>Read more...</a></div></div></article><article class=post><header class=post-header><h1 class=post-title><a class=post-link href=/post/design-pattern-notes/>设计模式学习笔记</a></h1><div class=post-meta><span class=post-time>September 2, 2019</span><div class=post-category><a href=/categories/notes/>Notes</a></div></div></header><div class=post-content><div class=post-summary>如无特殊声明：本文所有UML图均出自《图说设计模式》。在此特别鸣谢！ Singleton 单例模式解决了全局变量的问题，全局只能创建一个实例，保证任何请求该实例</div><div class=read-more><a href=/post/design-pattern-notes/ class=read-more-link>Read more...</a></div></div></article><article class=post><header class=post-header><h1 class=post-title><a class=post-link href=/post/concurrent-programming/>多线程学习笔记</a></h1><div class=post-meta><span class=post-time>August 29, 2019</span><div class=post-category><a href=/categories/notes/>Notes</a></div></div></header><div class=post-content><div class=post-summary>开一篇多线程学习笔记，记录下在实习过程中遇到的一些简单问题。 注意：这是一篇以学习笔记，难免有误，主要写给自己参考。请酌情判别，如有错误，也欢</div><div class=read-more><a href=/post/concurrent-programming/ class=read-more-link>Read more...</a></div></div></article><article class=post><header class=post-header><h1 class=post-title><a class=post-link href=/post/cpp-learn/>C++ 学习笔记</a></h1><div class=post-meta><span class=post-time>August 28, 2019</span><div class=post-category><a href=/categories/tech/>tech</a></div></div></header><div class=post-content><div class=post-summary><p>诚如是，Life is too short to learn c++. 此篇记录一些我在学习cpp过程中遇到的一些知识点，仅作记录并梳理之效。里面可能会有大量参考其他网络博客，如有侵权，请联系我删除之。</p><h2 id=reactor-vs-proactor>Reactor v.s. Proactor</h2><ul><li>epll/wait: reactor模式，不停轮询，发现有事做，就做！</li><li>asio: proactor模式，先注册好事件，如果事情发生了，通过回调函数处理。</li></ul><h2 id=几个常用的宏>几个常用的宏</h2><ul><li><code>__func__</code>: name of an function, exists in C99/C++11 (<code>__FUNCTION__</code> is non standard)</li><li><code>__LINE__</code>: line number of the code</li><li><code>__FILE__</code>: filename of the file</li><li><code>__DATE__</code> and <code>__TIME__</code>: as you wish</li></ul><h2 id=不要在ctor里调用虚函数>不要在ctor里调用虚函数</h2><p>总结来说：基类部分在派生类部分之前被构造，当基类构造函数执行时派生类中的数据成员还没被初始化。如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug。</p><p>ctor应该设计的尽量简单，确保对象可以被正确构造。在ctor中调用本类的非静态成员都是不安全的，因为他们还没被构造，而有些成员是依赖对象的，而此时对象还没有被成功构造。</p><h2 id=ctor不能是虚函数>ctor不能是虚函数</h2><ol><li><p>从存储空间角度：虚函数对应一个vtable（虚函数表），这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。</p></li><li><p>从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。
虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p></li><li><p>构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p></li></ol><p>——————————————————
版权声明：本文为CSDN博主「cainiao000001」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/cainiao000001/article/details/81603782</p><h2 id=虚函数的工作原理>虚函数的工作原理</h2><p><a href=https://zhuanlan.zhihu.com/p/60543586>https://zhuanlan.zhihu.com/p/60543586</a></p><p>C++ 规定了虚函数的行为，但将实现方法留给了编译器的作者。不需要知道实现方法也可以很好的使用虚函数，但了解虚函数的工作原理有助于更好地理解概念。</p><p>通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。</p><p>这种数组称为虚函数表（Virtual Function Table, vtbl）。</p><p>虚函数表是一个数组，数组的元素是指针，指针指的是虚函数的地址。</p><p>具有虚函数的类的实例，都会在头部存一个指向虚函数表的指针。</p><h2 id=常见类型所占空间大小>常见类型所占空间大小</h2><table><thead><tr><th>TYPE</th><th style=text-align:right>Bytes</th></tr></thead><tbody><tr><td>(unsigned) int</td><td style=text-align:right>4</td></tr><tr><td>(unsigned) short</td><td style=text-align:right>2</td></tr><tr><td>(unsigned) long</td><td style=text-align:right>8</td></tr><tr><td>float</td><td style=text-align:right>4</td></tr><tr><td>double</td><td style=text-align:right>8</td></tr><tr><td>long double</td><td style=text-align:right>16</td></tr><tr><td>(unsigned) char</td><td style=text-align:right>1</td></tr><tr><td>bool</td><td style=text-align:right>1</td></tr></tbody></table><p>指针占几个字节 指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关，譬如以前是16为地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就为8个字节。</p><blockquote><p>NOTE: 类成员函数指针一般为普通指针的两倍大小。</p></blockquote><p>literal <code>5.0</code>类型为<code>double</code>，<code>5.0f</code>类型为<code>float</code>。不加<code>f</code>后缀默认<code>double</code>.</p><h2 id=静态成员的初始化>静态成员的初始化</h2><p>当一个类包含静态成员时，最好的做法是在类中声明，在类外初始化。由于静态成员是所有对象共享的，如果在类内初始化，则每个对象构造时，都要执行一遍静态成员的初始化，这无疑是一种浪费。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>A</span><span class=o>::</span><span class=n>a</span> <span class=o>=</span> <span class=mi>233</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=n>string</span> <span class=n>str_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>done_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>B</span><span class=o>::</span><span class=n>str_</span> <span class=o>=</span> <span class=s>&#34;hello, i am static&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=析构函数的调用时机>析构函数的调用时机</h2><p>The destructor is called whenever an object&rsquo;s lifetime ends, which includes</p><ul><li>program termination, for objects with static storage duration</li><li>thread exit, for objects with thread-local storage duration</li><li>end of scope, for objects with automatic storage duration and for temporaries whose life was extended by binding to reference</li><li>delete-expressin, for objects with dynamic storage duration</li><li>end of the full expression, for nameless temporaries</li><li>stack unwinding (栈回溯), for objects with automatic storage duration when an exception escapes their block, uncaught.</li></ul><p>cf. <a href=https://en.cppreference.com/w/cpp/language/destructor>https://en.cppreference.com/w/cpp/language/destructor</a></p><h2 id=常量>常量</h2><h3 id=literal-constants>Literal constants</h3><p>字面值常量
Cf. <a href=https://www.learncpp.com/cpp-tutorial/literals/>https://www.learncpp.com/cpp-tutorial/literals/</a></p><h3 id=symbolic-constants>Symbolic constants</h3><p>符号常量
Cf. <a href=https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/>https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/</a></p><ol><li>Const variables must be initialized</li><li>Function parameters for arguments passed by value should not be made const.</li><li>Don’t use const with return by value.</li></ol><p><strong>Runtime vs compile-time constants</strong></p><p>Runtime constants are constants whose initialization values can only be resolved at runtime (when your program is running). The following are examples of runtime constants:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>printInt</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=c1>// x is a runtime constant because the value isn&#39;t known until the program is run
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Enter your age: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>age</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>usersAge</span> <span class=p>{</span> <span class=n>age</span> <span class=p>};</span> <span class=c1>// usersAge is a runtime constant because the value isn&#39;t known until the program is run
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Your age is: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printInt</span><span class=p>(</span><span class=n>age</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Compile-time constants are constants whose initialization values can be determined at compile-time (when your program is compiling). The following are examples of compile-time constants:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>double</span> <span class=n>gravity</span> <span class=p>{</span> <span class=mf>9.8</span> <span class=p>};</span> <span class=c1>// the compiler knows at compile-time that gravity will have value 9.8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=n>something</span> <span class=p>{</span> <span class=mi>1</span> <span class=o>+</span> <span class=mi>2</span> <span class=p>};</span> <span class=c1>// the compiler can resolve this at compiler time
</span></span></span></code></pre></td></tr></table></div></div><p>Compile-time constants enable the compiler to perform optimizations that aren’t available with runtime constants. For example, whenever gravity is used, the compiler can simply substitute the identifier gravity with the literal double 9.8.</p><p>To help provide more specificity, C++11 introduced the keyword <code>constexpr</code>, which ensures that a constant must be a compile-time constant.</p><blockquote><p>Any variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as <code>constexpr</code>.</p><p>Any variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as <code>const</code>.</p></blockquote><p>Note that literals are also implicitly constexpr, as the value of a literal is known at compile-time.</p><p>A <strong>constant expression</strong> is an expression that can be evaluated at compile-time. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=mi>3</span> <span class=o>+</span> <span class=mi>4</span><span class=p>;</span> <span class=c1>// 3 + 4 evaluated at compile-time
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>In the above program, because the literal values 3 and 4 are known at compile-time, the compiler can evaluate the expression 3 + 4 at compile-time and substitute in the resulting value 7. That makes the code faster because 3 + 4 no longer has to be calculated at runtime.</p><p>Constexpr variables can also be used in constant expressions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>constexpr</span> <span class=kt>int</span> <span class=n>x</span> <span class=p>{</span> <span class=mi>3</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=k>constexpr</span> <span class=kt>int</span> <span class=n>y</span> <span class=p>{</span> <span class=mi>4</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span> <span class=c1>// x + y evaluated at compile-time
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>In the above example, because x and y are constexpr, the expression x + y is a constant expression that can be evaluated at compile-time. Similar to the literal case, the compiler can substitute in the value 7.</p><h3 id=object-like-preprocessor-macros-vs-symbolic-constants>Object-like preprocessor macros v.s. symbolic constants</h3><p>Object-like macro has the form:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define identifier substitution_text
</span></span></span></code></pre></td></tr></table></div></div><p>Whenever the preprocessor encounters this directive, any further occurrence of <em>identifier</em> is replaced by <em>substitution_text</em>. The identifier is traditionally typed in all capital letters, using underscores to represent spaces.</p><blockquote><p>Avoid using #define to create symbolic constants macros. Use const or constexpr variables instead.</p></blockquote><p>Macros can have naming conflicts with normal code. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;someheader.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>beta</span> <span class=p>{</span> <span class=mi>5</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>beta</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>If someheader.h happened to #define a macro named beta, this simple program would break, as the preprocessor would replace the int variable beta’s name with whatever the macro’s value was. This is normally avoided by using all caps for macro names, but it can still happen.</p><h3 id=using-symbolic-constants-throughout-a-multi-file-program>Using symbolic constants throughout a multi-file program</h3><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/>https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/</a></p><h2 id=内存布局>内存布局</h2><h3 id=结构体>结构体</h3><p>C++规范在“结构”上使用了和C相同的，简单的内存布局原则：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>S</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>a</span><span class=p>;</span>     <span class=c1>// memory location #1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nl>b</span> <span class=p>:</span> <span class=mi>5</span><span class=p>;</span>  <span class=c1>// memory location #2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nl>c</span> <span class=p>:</span> <span class=mi>11</span><span class=p>,</span> <span class=c1>// memory location #2 (continued)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span>  <span class=o>:</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nl>d</span> <span class=p>:</span> <span class=mi>8</span><span class=p>;</span>  <span class=c1>// memory location #3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=nl>ee</span> <span class=p>:</span> <span class=mi>8</span><span class=p>;</span> <span class=c1>// memory location #4
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>obj</span><span class=p>;</span> <span class=c1>// The object &#39;obj&#39; consists of 4 separate memory locations
</span></span></span></code></pre></td></tr></table></div></div><ul><li>类的静态成员不占用类的空间，静态成员在程序数据段中。</li></ul><h3 id=对齐>对齐</h3><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/#comment-563585>https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/#comment-563585</a></p><p>Cf. <a href=http://www.catb.org/esr/structure-packing/>http://www.catb.org/esr/structure-packing/</a></p><h2 id=模板>模板</h2><h3 id=重载与特化>重载与特化</h3><p>从编译到函数模板的调用，编译器必须在非模板重载、模板重载和模板重载的特化间决定。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>T</span> <span class=o>&gt;</span> <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>              <span class=c1>// #1 ：模板重载
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>T</span> <span class=o>&gt;</span> <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=o>*</span><span class=p>);</span>             <span class=c1>// #2 ：模板重载
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>                     <span class=nf>f</span><span class=p>(</span><span class=kt>double</span><span class=p>);</span>         <span class=c1>// #3 ：非模板重载
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;&gt;</span>          <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>            <span class=c1>// #4 ： #1 的特化
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>);</span>        <span class=c1>// 调用 #1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span> <span class=c1>// 调用 #2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=mf>1.0</span><span class=p>);</span>        <span class=c1>// 调用 #3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>          <span class=c1>// 调用 #4
</span></span></span></code></pre></td></tr></table></div></div><p>注意只有非模板和初等模板重载参与重载决议。特化不是重载，且不受考虑。只有在重载决议选择最佳匹配初等函数模板后，才检验其特化以查看何为最佳匹配。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>T</span> <span class=o>&gt;</span> <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>    <span class=c1>// #1 ：所有类型的重载
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;&gt;</span>          <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span> <span class=c1>// #2 ：为指向 int 的指针特化 #1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>T</span> <span class=o>&gt;</span> <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=o>*</span><span class=p>);</span>   <span class=c1>// #3 ：所有指针类型的重载
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span> <span class=c1>// 调用 #3 ，即使通过 #1 的特化会是完美匹配
</span></span></span></code></pre></td></tr></table></div></div><p>即重载的优先级要高于特化。</p><p>关于模板函数重载的更多内容，参考<a href=https://en.cppreference.com/w/cpp/language/function_template>function_template</a>。</p><h2 id=预编译>预编译</h2><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/>https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/</a></p><h3 id=include><code>#include</code></h3><p>When you #include a file, the preprocessor replaces the #include directive with the contents of the included file. The included contents are then preprocessed (along with the rest of the file), and then compiled.</p><h3 id=macro-defines>Macro defines</h3><p>The #define directive can be used to create a macro. In C++, a macro is a rule that defines how input text is converted into replacement output text.</p><p>There are two basic types of macros: <em>object-like macros</em>, and <em>function-like macros</em>.
Object-like macros can be defined in one of two ways:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define identifier
</span></span></span><span class=line><span class=cl><span class=cp>#define identifier substitution_text
</span></span></span></code></pre></td></tr></table></div></div><h3 id=object-like-macros-dont-affect-other-preprocessor-directives>Object-like macros don’t affect other preprocessor directives</h3><p>结论：宏展开在预编译指令(Preprocessor directives)无效。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define PRINT_JOE
</span></span></span><span class=line><span class=cl><span class=cp>#ifdef PRINT_JOE    </span><span class=c1>// 此处会否将&#39;PRINT_JOE&#39;替换为空呢？
</span></span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span></code></pre></td></tr></table></div></div><p>Macros only cause text substitution for normal code. Other preprocessor commands are ignored. Consequently, the PRINT_JOE in #ifdef PRINT_JOE is left alone.</p><p>For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define FOO 9 </span><span class=c1>// Here&#39;s a macro substitution
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef FOO </span><span class=c1>// This FOO does not get replaced because it’s part of another preprocessor directive
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>FOO</span><span class=p>;</span> <span class=c1>// This FOO gets replaced with 9 because it&#39;s part of the normal code
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#endif
</span></span></span></code></pre></td></tr></table></div></div><p>In actuality, the output of the preprocessor contains no directives at all &ndash; they are all resolved/stripped out before compilation, because the compiler wouldn’t know what to do with them.</p><h3 id=the-scope-of-defines>The scope of defines</h3><p>Once the preprocessor has finished, all defined identifiers from that file are discarded. <strong>This means that directives are only valid from the point of definition to the end of the file in which they are defined</strong>. Directives defined in one code file do not have impact on other code files in the same project.</p><p>宏定义仅在本文件有效，一旦预编译阶段结束，所有宏都将失效。因为，预编译就是将所有的预编译指令都处理掉，该替换的替换（宏展开），该选择的选择，该丢弃的丢弃（条件编译），然后交给编译器去编译，谨记：编译器是读不懂预编译指令的！</p><p>Consider the following example:</p><p>function.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>doSomething</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef PRINT
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Printing!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#ifndef PRINT
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Not printing!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>main.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>doSomething</span><span class=p>();</span> <span class=c1>// forward declaration for function doSomething()
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#define PRINT
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>doSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The above program will print:</p><pre tabindex=0><code>Not printing!
</code></pre><p>Even though PRINT was defined in main.cpp, that doesn’t have any impact on any of the code in function.cpp (PRINT is only #defined from the point of definition to the end of main.cpp). This will be of consequence when we discuss header guards in a future lesson.</p><h2 id=header-files>Header files</h2><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/header-files/>https://www.learncpp.com/cpp-tutorial/header-files/</a></p><p>对于多文件项目，文件是单独编译的。要想调用一个自定义函数，linker必须能找到这个函数在哪里定义。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>  <span class=c1>// forward declaration
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// add(3, 5);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>上述文件是可以编译通过的，因为没有发生对<code>add</code>的调用，所以linker不会去找<code>add</code>的定义（当然如果要找也找不到）。</p><p>但是如果某处发起了对<code>add</code>的调用（例如去掉注释），那么上述程序在link阶段会报错：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>yychi@~&gt; clang test_linker.cpp
</span></span><span class=line><span class=cl>/usr/bin/ld: /tmp/test_linker-e1bb8b.o: in <span class=k>function</span> <span class=sb>`</span>main<span class=s1>&#39;:
</span></span></span><span class=line><span class=cl><span class=s1>test_linker.cpp:(.text+0x1a): undefined reference to `add(int, int)&#39;</span>
</span></span><span class=line><span class=cl>clang-13: error: linker <span class=nb>command</span> failed with <span class=nb>exit</span> code <span class=m>1</span> <span class=o>(</span>use -v to see invocation<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>在多文件编程时，往往需要forawrd declaration，这些前置声明必须在其他某个地方被定义且只被定义一次。这样，linker才能正确的完成链接。任何重复定义或未定义都会在link阶段报错。</p><p>考虑如下例子：</p><p>add.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>main.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>z</span> <span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;z=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>z</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在编译main.cpp的时候，因为有<code>add</code>的前置声明，所以可以通过。但为了link的时候能够找到<code>add</code>的定义，add.cpp必须也被编译，所以正确的编译方式应该是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ clang main.cpp add.cpp
</span></span></code></pre></td></tr></table></div></div><h3 id=use-of-header-files>Use of header files</h3><p>从上面的论述我们隐约可见，在多文件编程中，我们可能会大量的使用前置声明（forward declaration），一旦文件多起来，这将非常枯燥。所以头文件的出现就是为了解决这个问题：把所有的声明放在一起。</p><p>Let’s write a header file to relieve us of this burden. Writing a header file is surprisingly easy, as header files only consist of two parts:</p><ol><li>A header guard.</li><li>The actual content of the header file, which should be the forward declarations for all of the identifiers we want other files to be able to see.</li></ol><p>add.h:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 1) We really should have a header guard here, but will omit it for simplicity (we&#39;ll cover header guards in the next lesson)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 2) This is the content of the .h file, which is where the declarations go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>);</span> <span class=c1>// function prototype for add.h -- don&#39;t forget the semicolon!
</span></span></span></code></pre></td></tr></table></div></div><p>main.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;add.h&#34; // Insert contents of add.h at this point.  Note use of double quotes here.</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;The sum of 3 and 4 is &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>add.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;add.h&#34; // Insert contents of add.h at this point.  Note use of double quotes here.</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>When the preprocessor processes the <code>#include "add.h"</code> line, it copies the contents of <em>add.h</em> into the current file at that point. Because our <em>add.h</em> contains a forward declaration for function <em>add</em>, that forward declaration will be copied into <em>main.cpp</em>. The end result is a program that is functionally the same as the one where we manually added the forward declaration at the top of <em>main.cpp</em>.</p><p>Consequently, our program will compile and link correctly.
<img src="https://www.learncpp.com/images/CppTutorial/Section1/IncludeHeader.png?ezimgfmt=rs:647x377/rscb2/ng:webp/ngcb2" alt></p><h3 id=two-wrong-cases>Two wrong cases</h3><p><img src=wrong_header.png alt="header has function definition"></p><p>如上图所示，会产生一个重复定义的错误。由于add.h中包含了函数定义，而非前置声明。编译main.cpp的时候，add.h中的代码插入到main.cpp中，产生一次<code>add</code>函数的定义。同理，编译add.cpp的时候也定义了一次<code>add</code>函数。link阶段会发生歧义，以致报错。</p><p>此时如果不编译add.cpp其实是可行的：
<img src=header2.png alt="compile main.cpp only"></p><p>但谁又能保证只有一个文件<code>#include "add.h"</code>呢？所以头文件中应该只包含声明，而不应该包含实现。</p><blockquote><p>The primary purpose of a header file is to propagate declarations to code files.</p></blockquote><p>Key insight: Header files allow us to put declarations in one location and then import them wherever we need them. This can save a lot of typing in multi-file programs.</p><p>Header files should generally not contain function and variable definitions, so as not to violate the one definition rule. An exception is made for symbolic constants (which we cover in lesson <a href=https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/>4.15 &ndash; Symbolic constants: const and constexpr variables</a>).</p><p><strong>标准库自动链接</strong></p><blockquote><p>注意：clang不会自动链接，需要手动链接
<code>clang main.cpp -lstdc++</code></p></blockquote><p>When it comes to functions and variables, it’s worth keeping in mind that header files typically only contain function and variable declarations, not function and variable definitions (otherwise a violation of the one definition rule could result). std::cout is forward declared in the iostream header, but defined as part of the C++ standard library, which is automatically linked into your program during the linker phase.</p><p><img src=cout.png alt=cout></p><p><strong>The #include order of header files</strong></p><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/header-files/>https://www.learncpp.com/cpp-tutorial/header-files/</a> for &ldquo;the #inclue order of header files&rdquo;.</p><h2 id=a-view-of-memory-and-fundamental-data-types-in-cpp>A view of memory and fundamental data types in cpp</h2><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/>https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/</a></p><p>The smallest unit of memory is a binary digit (also called a bit), which can hold a value of 0 or 1. You can think of a bit as being like a traditional light switch &ndash; either the light is off (0), or it is on (1). There is no in-between. If you were to look at a random segment of memory, all you would see is …011010100101010… or some combination thereof.</p><p>Memory is organized into sequential units called memory addresses (or addresses for short). Similar to how a street address can be used to find a given house on a street, the memory address allows us to find and access the contents of memory at a particular location.</p><p>Perhaps surprisingly, in modern computer architectures, each bit does not get its own unique memory address. This is because the number of memory addresses are limited, and the need to access data bit-by-bit is rare. Instead, each memory address holds 1 byte of data. A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.</p><p><strong>Data types</strong></p><p>Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way. You have already seen one example of a data type: the integer. When we declare a variable as an integer, we are telling the compiler “the piece of memory that this variable uses is going to be interpreted as an integer value”.</p><p>When you give an object a value, the compiler and CPU take care of encoding your value into the appropriate sequence of bits for that data type, which are then stored in memory (<strong>remember: memory can only store bits</strong>). For example, if you assign an integer object the value 65, that value is converted to the sequence of bits 0100 0001 and stored in the memory assigned to the object.</p><p>Conversely, when the object is evaluated to produce a value, that sequence of bits is reconstituted back into the original value. Meaning that 0100 0001 is converted back into the value 65.</p><p>Fortunately, the compiler and CPU do all the hard work here, so you generally don’t need to worry about how values get converted into bit sequences and back.</p><p>All you need to do is pick a data type for your object that best matches your desired use.</p><p>谨记：内存只能存bit，只能寻址寻到byte这一层，如果数据按内存边界对齐，寻址会更快（一次读）。</p><p>由于内存地址空间有限，且按bit寻址的场景很少，所以寻址单位一般是byte。A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.</p><h3 id=移位>移位</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdint&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>int32_t</span> <span class=n>a</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>b</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>n_shift</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;a=&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;; b=&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;left shift &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n_shift</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; bit(s) of a is: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>n_shift</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;left shift &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n_shift</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; bit(s) of b is: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>n_shift</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;right shift &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n_shift</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; bit(s) of a is: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>a</span> <span class=o>&gt;&gt;</span> <span class=n>n_shift</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;right shift &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n_shift</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; bit(s) of b is: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>b</span> <span class=o>&gt;&gt;</span> <span class=n>n_shift</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int32_t</span> <span class=n>a</span> <span class=o>=</span> <span class=mh>0xffffffff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>b</span> <span class=o>=</span> <span class=mh>0xffffffff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;------------</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=mh>0xbfffffff</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Output on my machine:
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>a=-1; b=4294967295
</span></span></span><span class=line><span class=cl><span class=cm>left shift 1 bit(s) of a is: -2
</span></span></span><span class=line><span class=cl><span class=cm>left shift 1 bit(s) of b is: 4294967294
</span></span></span><span class=line><span class=cl><span class=cm>right shift 1 bit(s) of a is: -1
</span></span></span><span class=line><span class=cl><span class=cm>right shift 1 bit(s) of b is: 2147483647
</span></span></span><span class=line><span class=cl><span class=cm>------------
</span></span></span><span class=line><span class=cl><span class=cm>a=-1073741825; b=4294967295
</span></span></span><span class=line><span class=cl><span class=cm>left shift 1 bit(s) of a is: 2147483646
</span></span></span><span class=line><span class=cl><span class=cm>left shift 1 bit(s) of b is: 4294967294
</span></span></span><span class=line><span class=cl><span class=cm>right shift 1 bit(s) of a is: -536870913
</span></span></span><span class=line><span class=cl><span class=cm>right shift 1 bit(s) of b is: 2147483647
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></td></tr></table></div></div><p>从内存连续bit来看，a和b都是存了4 byte的1，区别仅仅是data type不一样，导致了截然不同的结果。</p><p><strong>移位操作</strong></p><ol><li>右移<ol><li>无符号右移，低位丢失高位补0</li><li>有符号右移，低位丢失，高位补符号位（正为0, 负为1）</li></ol></li><li>左移：高位丢失，低位补0</li></ol><p>a和b左移一位都得到：</p><pre tabindex=0><code>0xfffffffe: 如果是int解释为-2, unsigned int解释为4294967294=2^32 - 2
</code></pre><p>a右移一位得到</p><pre tabindex=0><code>0xffffffff: 注意负数右移，高位补1，int解释为-1
</code></pre><p>b右移一位得到</p><pre tabindex=0><code>0x7fffffff: 高位补0, unsigned int解释为2147483647=2^31-1
</code></pre><p>注意，负的可能左移成正的，因此，有符号的移位是不安全的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>signed</span> <span class=kt>int</span> <span class=n>s</span> <span class=p>{</span> <span class=o>-</span><span class=mi>1</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>u</span> <span class=p>{</span> <span class=mi>1</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>&lt;</span> <span class=n>u</span><span class=p>)</span> <span class=c1>// -1 is implicitly converted to 4294967295, and 4294967295 &lt; 1 is false
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;-1 is less than 1</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;1 is less than -1</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=c1>// this statement executes
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>NOTE:</p><ol><li>注意无符号数相减得负数会导致溢出</li><li>usigned和<code>--</code>运算符，可能减至负数溢出</li><li>除非确定变量值非负，否则尽量避免使用unsigned</li><li>切忌不要在数学计算中混用unsigned和signed，此时signed会隐式转换为unsigned</li><li>unsigned numbers are preferred when dealing with bit manipulation</li><li><code>std::int8_t</code>和<code>std::uint8_t</code>可能知识<code>char</code>和<code>unsigned char</code>的别名，可能有坑（参考：https://www.learncpp.com/cpp-tutorial/introduction-to-type-conversion-and-static_cast/）</li></ol><p><strong>Best practice</strong></p><p>Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.</p><h3 id=字节序>字节序</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * This file test the endian of your machine:
</span></span></span><span class=line><span class=cl><span class=cm> * big-endian or little-endian, by visiting
</span></span></span><span class=line><span class=cl><span class=cm> * the memory sequentially byte by byte of
</span></span></span><span class=line><span class=cl><span class=cm> * a intendly constructed integer.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdint&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// convert to char* so we can visit the memory byte by byte
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>_ptr</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// print the value of each byte in ptr
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>_ptr</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>a</span> <span class=o>=</span> <span class=mh>0x01020304</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * if it prints 4321, indicates 低位在前，对应little-endian
</span></span></span><span class=line><span class=cl><span class=cm>     * it it prints 1234, indicates 高位在前，对应big-endian
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Output on my machine
</span></span></span><span class=line><span class=cl><span class=cm>4321
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></td></tr></table></div></div><p>字节序就是计算机存储数据的时候将低位数据存在低位地址还是高位地址。举个例子，数值0x2211使用两个字节储存：高位字节是0x22，低位字节是0x11。</p><ul><li>大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。</li><li>小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。</li></ul><p>如果太多记不住，至少要记住：</p><ol><li>字节序的概念: 读一段内存从低位向高位读（从左往右），先读到高位字节还是低位字节</li><li>符合人类读写数值的方法是大端序（big-endian）</li></ol><p>既然如此，我们要判断一台机器是big-endian还是little-endian，只需要构造一端内存，按字节从低位地址向高位地址访问，看看低位地址存的是高位字节，还是低位字节即可。</p><p>且看上述代码，构造了一个整数0x01020304，然后通过将首地址转成<code>char*</code>的方式去按字节读取内存中的值（这样做的目的是，<code>char*</code>可以逐字节的读取内存；而<code>int*</code>一次指针移动会移动<code>sizeof(int)</code>个字节）。读出来如果是符合书写习惯的1234, 则表明机器是big-endian, 反之little-endian.</p><p>这也是一段内存的两种不同的解释方式，recall that <strong>Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way</strong>.</p><h2 id=链接linkage>链接（Linkage）</h2><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/internal-linkage/>https://www.learncpp.com/cpp-tutorial/internal-linkage/</a></p><p>Identifiers have another property named <code>linkage</code>. An identifier’s <strong>linkage</strong> determines whether other declarations of that name refer to the same object or not.</p><p>Local variables have <code>no linkage</code>, which means that each declaration refers to a unique object.</p><p>Global variable and functions identifiers can have either <code>internal linkage</code> or <code>external linkage</code>.</p><p>An identifier with <strong>internal linkage</strong> can be seen and used within a single file, but it is not accessible from other files (that is, it is not exposed to the linker). This means that if two files have identically named identifiers with internal linkage, those identifiers will be treated as independent.</p><p>To make a non-constant global variable internal, we use the static keyword.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>g_x</span><span class=p>;</span> <span class=c1>// non-constant globals have external linkage by default, but can be given internal linkage via the static keyword
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span> <span class=p>{</span> <span class=mi>1</span> <span class=p>};</span> <span class=c1>// const globals have internal linkage by default
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>g_z</span> <span class=p>{</span> <span class=mi>2</span> <span class=p>};</span> <span class=c1>// constexpr globals have internal linkage by default
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>To see it, we take</p><p>a.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_x</span> <span class=o>=</span> <span class=mi>22</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span> <span class=o>=</span> <span class=mi>33</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>g_z</span> <span class=o>=</span> <span class=mi>44</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>main.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_x</span> <span class=o>=</span> <span class=mi>222</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span> <span class=o>=</span> <span class=mi>333</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>g_z</span> <span class=o>=</span> <span class=mi>444</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&#34;</span><span class=p>,</span> <span class=n>g_x</span><span class=p>,</span> <span class=n>g_y</span><span class=p>,</span> <span class=n>g_z</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>if we compile only main.cpp, it works fine and outputs:</p><pre tabindex=0><code>glabal variable (g_x, g_y, g_z) is (222, 333, 444)
</code></pre><p>But if we compile both, it gets</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ clang main.cpp a.cpp
</span></span><span class=line><span class=cl>/usr/bin/ld: /tmp/a-ea4f54.o:<span class=o>(</span>.data+0x0<span class=o>)</span>: multiple definition of <span class=sb>`</span>g_x<span class=err>&#39;</span><span class=p>;</span> /tmp/main-c44eb4.o:<span class=o>(</span>.data+0x0<span class=o>)</span>: first defined here
</span></span><span class=line><span class=cl>clang-13: error: linker <span class=nb>command</span> failed with <span class=nb>exit</span> code <span class=m>1</span> <span class=o>(</span>use -v to see invocation<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>As we sligtly modify main.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=n>g_x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span> <span class=o>=</span> <span class=mi>333</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>g_z</span> <span class=o>=</span> <span class=mi>444</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&#34;</span><span class=p>,</span> <span class=n>g_x</span><span class=p>,</span> <span class=n>g_y</span><span class=p>,</span> <span class=n>g_z</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>it&rsquo;s compiled and linked properly with the output:</p><pre tabindex=0><code>glabal variable (g_x, g_y, g_z) is (22, 333, 444)
</code></pre><p>noting that the <code>g_x</code> has the value 22 which is defined in a.cpp, we find out the global non-const variable has external linkage. And the properly compilation and linking show that global const has internal linkage.</p><h3 id=external-linkage>External linkage</h3><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/external-linkage/>https://www.learncpp.com/cpp-tutorial/external-linkage/</a></p><p>An identifier with <strong>external linkage</strong> can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration). In this sense, identifiers with external linkage are truly “global” in that they can be used anywhere in your program!</p><p><strong>Functions have external linkage by default</strong></p><p>In order to call a function defined in another file, you must place a <code>forward declaration</code> for the function in any other files wishing to use the function. <u>The forward declaration tells the compiler about the existence of the function, and the linker connects the function calls to the actual function definition.</u></p><p><strong>Global variables with external linkage</strong></p><p>Global variables with external linkage are sometimes called <strong>external variables</strong>. To make a global variable external (and thus accessible by other files), we can use the <code>extern</code> keyword to do so:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_x</span> <span class=p>{</span> <span class=mi>2</span> <span class=p>};</span> <span class=c1>// non-constant globals are external by default
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span> <span class=p>{</span> <span class=mi>3</span> <span class=p>};</span> <span class=c1>// const globals can be defined as extern, making them external
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>g_z</span> <span class=p>{</span> <span class=mi>3</span> <span class=p>};</span> <span class=c1>// constexpr globals can be defined as extern, making them external (but this is useless, see the note in the next section)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Non-const global variables are external by default (if used, the <code>extern</code> keyword will be ignored).</p><p>To actually use an external global variable that has been defined in another file, you also must place a <code>forward declaration</code> for the global variable in any other files wishing to use the variable. For variables, creating a forward declaration is also done via the <code>extern</code> keyword (with no initialization value).</p><p>Here is an example of using a variable forward declaration:</p><p>a.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// global variable definitions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>g_x</span> <span class=p>{</span> <span class=mi>2</span> <span class=p>};</span> <span class=c1>// non-constant globals have external linkage by default
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span> <span class=p>{</span> <span class=mi>3</span> <span class=p>};</span> <span class=c1>// this extern gives g_y external linkage
</span></span></span></code></pre></td></tr></table></div></div><p>main.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=n>g_x</span><span class=p>;</span> <span class=c1>// this extern is a forward declaration of a variable named g_x that is defined somewhere else
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span><span class=p>;</span> <span class=c1>// this extern is a forward declaration of a const variable named g_y that is defined somewhere else
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>g_x</span><span class=p>;</span> <span class=c1>// prints 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Note that the <code>extern</code> keyword has different meanings in different contexts. In some contexts, <code>extern</code> means “give this variable external linkage”. In other contexts, <code>extern</code> means “this is a forward declaration for an external variable that is defined somewhere else”.</p><p><strong>Summary</strong></p><p><em>Scope</em> determines where a variable is accessible. <em>Duration</em> determines where a variable is created and destroyed. <em>Linkage</em> determines whether the variable can be exported to another file or not.</p><h2 id=inline-function>Inline function</h2><p>考虑如下场景，有一段代码很独立，适合抽成一个函数，但你又担心函数调用开销，此时inline function就是你的最佳选择。关于合适使用inline function，下面这段话给了一定的意见：</p><blockquote><p>For functions that are large and/or perform complex tasks, the overhead of the function call is typically insignificant compared to the amount of time the function takes to run. However, for small functions, the overhead costs can be larger than the time needed to actually execute the function’s code! In cases where a small function is called often, using a function can result in a significant performance penalty over writing the same code in-place.</p></blockquote><p>Inline function的好处包括：</p><ol><li>没有函数调用的开销</li><li>编译器对展开后的代码有更大的优化空间（如常量替换）</li></ol><p>However, inline expansion has its own potential cost: if the body of the function being expanded takes more instructions than the function call being replaced, then each inline expansion will cause the executable to grow larger. Larger executables tend to be slower (due to not fitting as well in caches).</p><blockquote><p>注意：inline只是对编译器的一个建议，是否会真的展开取决于编译器的优化策略。</p></blockquote><p>However, in modern C++, the <code>inline</code> keyword is no longer used to request that a function be expanded inline. There are quite a few reasons for this:</p><ul><li>Using <code>inline</code> to request inline expansion is a form of premature optimization, and misuse could actually harm performance.</li><li>The <code>inline</code> keyword is just a hint &ndash; the compiler is completely free to ignore a request to inline a function. This is likely to be the result if you try to inline a lengthy function! <strong>The compiler is also free to perform inline expansion of functions that do not use the <code>inline</code> keyword</strong> as part of its normal set of optimizations.</li><li>The <code>inline</code> keyword is defined at the wrong level of granularity. We use the <code>inline</code> keyword on a function declaration, but inline expansion is actually determined per function call. It may be beneficial to expand some function calls and detrimental to expand others, and there is no syntax to affect this.</li></ul><p>注意：在modern cpp中，用inline修饰的不违反ODR（one definition rule），因此可用于</p><ul><li>头文件中修饰常量作为global const的最佳方案<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li>头文件中修饰constexpr函数<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>使所有include该文件的源文件都能使用该函数，注意constexpr函数是默认inline的</li></ul><blockquote><p>Allowing functions with a constexpr return type to be evaluated at either compile-time or runtime was allowed so that a single function can serve both cases. Otherwise, you’d need to have separate functions (a constexpr version and a non-constexpr version) &ndash; and since return type isn’t considered in function overload resolution, you’d have to name the functions different things!</p><p>A constexpr function that is eligible to be evaluated at compile-time will only be evaluated at compile-time if the return value is used where a constant expression is required. Otherwise, compile-time evaluation is not guaranteed.</p><p>Thus, a constexpr function is better thought of as “can be used in a constant expression”, not “will be evaluated at compile-time”.</p></blockquote><h2 id=unnamed-namespace>Unnamed namespace</h2><p>An <strong>unnamed namespace</strong> (also called an <strong>anonymous namespace</strong>) is a namespace that is defined without a name, like so:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=c1>// unnamed namespace
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>doSomething</span><span class=p>()</span> <span class=c1>// can only be accessed in this file
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;v1</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>doSomething</span><span class=p>();</span> <span class=c1>// we can call doSomething() without a namespace prefix
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>特点：</p><ol><li>All content declared in an unnamed namespace is treated as if it is part of the parent namespace.</li><li>All identifiers inside an unnamed namespace are treated as if they had <strong>internal linkage</strong>.</li></ol><p>解决的问题：Unnamed namespaces will also keep user-defined types (something we’ll discuss in a later lesson) local to the file, something for which there is no alternative equivalent mechanism to do.</p><p><strong>About <code>switch</code> clause</strong></p><p><em>Put another way, defining a variable without an initializer is just telling the compiler that the variable is now in scope from that point on. This happens at compile time, and doesn’t require the definition to actually be executed at runtime.</em></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>calculate</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>char</span> <span class=n>op</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>op</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=sc>&#39;+&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=sc>&#39;-&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>-</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=sc>&#39;*&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=sc>&#39;/&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>/</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=sc>&#39;%&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>%</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>invalid_arguments</span><span class=p>(</span><span class=s>&#34;invalid operator&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=pointer-to-functions>Pointer to functions</h2><p>The syntax for creating a non-const function pointer is one of the ugliest things you will ever see in C++:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// fcnPtr is a pointer to a function that takes no arguments and returns an integer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fcnPtr</span><span class=p>)();</span>
</span></span></code></pre></div><p>In the above snippet, fcnPtr is a pointer to a function that has no parameters and returns an integer. fcnPtr can point to any function that matches this type.</p><p>To make a const function pointer, the const goes after the asterisk:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=k>const</span> <span class=n>fcnPtr</span><span class=p>)();</span>
</span></span></code></pre></div><p>If you put the const before the int, then that would indicate the function being pointed to would return a const int.</p></div><div class=read-more><a href=/post/cpp-learn/ class=read-more-link>Read more...</a></div></div></article><article class=post><header class=post-header><h1 class=post-title><a class=post-link href=/post/blog-trans/>博客迁移记录</a></h1><div class=post-meta><span class=post-time>August 25, 2019</span><div class=post-category><a href=/categories/notes/>Notes</a></div></div></header><div class=post-content><div class=post-summary>终于还是干了！很早以前就有了这个想法，起初使用Hexo搭的博客，折腾了一段时间，选了一个不错的主题Melody。一切都进行的很好，直到有一天</div><div class=read-more><a href=/post/blog-trans/ class=read-more-link>Read more...</a></div></div></article></section><nav class=pagination><a class=prev href=/page/2/><i class="iconfont icon-left"></i>
<span class=prev-text>Prev</span></a>
<a class=next href=/page/4/><span class=next-text>Next</span>
<i class="iconfont icon-right"></i></a></nav></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:guyueshui002@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/guyueshui class="iconfont icon-github" title=github></a>
<a href=/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>site pv: <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span></span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv>site uv: <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span></span></div><span class=copyright-year>&copy;
2018 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>Yychi</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>