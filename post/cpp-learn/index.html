<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>C++ 学习笔记 - 水阙</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Yychi"><meta name=description content="诚如是，Life is too short to learn c++. 此篇记录一些我在学习cpp过程中遇到的一些知识点，仅作记录并梳理之效。里面可能会有大量参考其他网络博客，如有侵权，请联系我删除之。
Reactor v.s. Proactor epll/wait: reactor模式，不停轮询，发现有事做，就做！ asio: proactor模式，先注册好事件，如果事情发生了，通过回调函数处理。 几个常用的宏 __func__: name of an function, exists in C99/C++11 (__FUNCTION__ is non standard) __LINE__: line number of the code __FILE__: filename of the file __DATE__ and __TIME__: as you wish 不要在ctor里调用虚函数 总结来说：基类部分在派生类部分之前被构造，当基类构造函数执行时派生类中的数据成员还没被初始化。如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug。
ctor应该设计的尽量简单，确保对象可以被正确构造。在ctor中调用本类的非静态成员都是不安全的，因为他们还没被构造，而有些成员是依赖对象的，而此时对象还没有被成功构造。
ctor不能是虚函数 从存储空间角度：虚函数对应一个vtable（虚函数表），这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。
从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。 虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。
—————————————————— 版权声明：本文为CSDN博主「cainiao000001」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/cainiao000001/article/details/81603782
虚函数的工作原理 https://zhuanlan.zhihu.com/p/60543586
C++ 规定了虚函数的行为，但将实现方法留给了编译器的作者。不需要知道实现方法也可以很好的使用虚函数，但了解虚函数的工作原理有助于更好地理解概念。
通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。
这种数组称为虚函数表（Virtual Function Table, vtbl）。
虚函数表是一个数组，数组的元素是指针，指针指的是虚函数的地址。
具有虚函数的类的实例，都会在头部存一个指向虚函数表的指针。
常见类型所占空间大小 TYPE Bytes (unsigned) int 4 (unsigned) short 2 (unsigned) long 8 float 4 double 8 long double 16 (unsigned) char 1 bool 1 指针占几个字节 指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关，譬如以前是16为地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就为8个字节。
NOTE: 类成员函数指针一般为普通指针的两倍大小。
literal 5.0类型为double，5.0f类型为float。不加f后缀默认double.
静态成员的初始化 当一个类包含静态成员时，最好的做法是在类中声明，在类外初始化。由于静态成员是所有对象共享的，如果在类内初始化，则每个对象构造时，都要执行一遍静态成员的初始化，这无疑是一种浪费。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct A { static int a; int b; void fun(); ... }; int A::a = 233; class B { public: void fun(); ... private: static string str_; bool done_; }; string B::str_ = &amp;#34;hello, i am static&amp;#34;; 析构函数的调用时机 The destructor is called whenever an object&amp;rsquo;s lifetime ends, which includes
program termination, for objects with static storage duration thread exit, for objects with thread-local storage duration end of scope, for objects with automatic storage duration and for temporaries whose life was extended by binding to reference delete-expressin, for objects with dynamic storage duration end of the full expression, for nameless temporaries stack unwinding (栈回溯), for objects with automatic storage duration when an exception escapes their block, uncaught. cf. https://en.cppreference.com/w/cpp/language/destructor
常量 Literal constants 字面值常量 Cf. https://www.learncpp.com/cpp-tutorial/literals/
Symbolic constants 符号常量 Cf. https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/
Const variables must be initialized Function parameters for arguments passed by value should not be made const. Don’t use const with return by value. Runtime vs compile-time constants
Runtime constants are constants whose initialization values can only be resolved at runtime (when your program is running). The following are examples of runtime constants:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &amp;lt;iostream&amp;gt; void printInt(const int x) // x is a runtime constant because the value isn&amp;#39;t known until the program is run { std::cout &amp;lt;&amp;lt; x; } int main() { std::cout &amp;lt;&amp;lt; &amp;#34;Enter your age: &amp;#34;; int age{}; std::cin &amp;gt;&amp;gt; age; const int usersAge { age }; // usersAge is a runtime constant because the value isn&amp;#39;t known until the program is run std::cout &amp;lt;&amp;lt; &amp;#34;Your age is: &amp;#34;; printInt(age); return 0; } Compile-time constants are constants whose initialization values can be determined at compile-time (when your program is compiling). The following are examples of compile-time constants:
1 2 const double gravity { 9.8 }; // the compiler knows at compile-time that gravity will have value 9.8 const int something { 1 + 2 }; // the compiler can resolve this at compiler time Compile-time constants enable the compiler to perform optimizations that aren’t available with runtime constants. For example, whenever gravity is used, the compiler can simply substitute the identifier gravity with the literal double 9.8.
To help provide more specificity, C++11 introduced the keyword constexpr, which ensures that a constant must be a compile-time constant.
Any variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as constexpr.
Any variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as const.
Note that literals are also implicitly constexpr, as the value of a literal is known at compile-time.
A constant expression is an expression that can be evaluated at compile-time. For example:
1 2 3 4 5 6 #include &amp;lt;iostream&amp;gt; int main() { std::cout &amp;lt;&amp;lt; 3 + 4; // 3 + 4 evaluated at compile-time return 0; } In the above program, because the literal values 3 and 4 are known at compile-time, the compiler can evaluate the expression 3 + 4 at compile-time and substitute in the resulting value 7. That makes the code faster because 3 + 4 no longer has to be calculated at runtime.
Constexpr variables can also be used in constant expressions:
1 2 3 4 5 6 7 8 #include &amp;lt;iostream&amp;gt; int main() { constexpr int x { 3 }; constexpr int y { 4 }; std::cout &amp;lt;&amp;lt; x + y; // x + y evaluated at compile-time return 0; } In the above example, because x and y are constexpr, the expression x + y is a constant expression that can be evaluated at compile-time. Similar to the literal case, the compiler can substitute in the value 7.
Object-like preprocessor macros v.s. symbolic constants Object-like macro has the form:
1 #define identifier substitution_text Whenever the preprocessor encounters this directive, any further occurrence of identifier is replaced by substitution_text. The identifier is traditionally typed in all capital letters, using underscores to represent spaces.
Avoid using #define to create symbolic constants macros. Use const or constexpr variables instead.
Macros can have naming conflicts with normal code. For example:
1 2 3 4 5 6 7 8 9 10 #include &amp;#34;someheader.h&amp;#34; #include &amp;lt;iostream&amp;gt; int main() { int beta { 5 }; std::cout &amp;lt;&amp;lt; beta; return 0; } If someheader.h happened to #define a macro named beta, this simple program would break, as the preprocessor would replace the int variable beta’s name with whatever the macro’s value was. This is normally avoided by using all caps for macro names, but it can still happen.
Using symbolic constants throughout a multi-file program Cf. https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/
内存布局 结构体 C++规范在“结构”上使用了和C相同的，简单的内存布局原则：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐。
1 2 3 4 5 6 7 8 9 10 struct S { char a; // memory location #1 int b : 5; // memory location #2 int c : 11, // memory location #2 (continued) char : 0, int d : 8; // memory location #3 struct { int ee : 8; // memory location #4 } e; } obj; // The object &amp;#39;obj&amp;#39; consists of 4 separate memory locations 类的静态成员不占用类的空间，静态成员在程序数据段中。 对齐 Cf. https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/#comment-563585
Cf. http://www.catb.org/esr/structure-packing/
模板 重载与特化 从编译到函数模板的调用，编译器必须在非模板重载、模板重载和模板重载的特化间决定。
1 2 3 4 5 6 7 8 9 template&amp;lt; class T &amp;gt; void f(T); // #1 ：模板重载 template&amp;lt; class T &amp;gt; void f(T*); // #2 ：模板重载 void f(double); // #3 ：非模板重载 template&amp;lt;&amp;gt; void f(int); // #4 ： #1 的特化 f(&amp;#39;a&amp;#39;); // 调用 #1 f(new int(1)); // 调用 #2 f(1.0); // 调用 #3 f(1); // 调用 #4 注意只有非模板和初等模板重载参与重载决议。特化不是重载，且不受考虑。只有在重载决议选择最佳匹配初等函数模板后，才检验其特化以查看何为最佳匹配。
1 2 3 4 5 template&amp;lt; class T &amp;gt; void f(T); // #1 ：所有类型的重载 template&amp;lt;&amp;gt; void f(int*); // #2 ：为指向 int 的指针特化 #1 template&amp;lt; class T &amp;gt; void f(T*); // #3 ：所有指针类型的重载 f(new int(1)); // 调用 #3 ，即使通过 #1 的特化会是完美匹配 即重载的优先级要高于特化。
关于模板函数重载的更多内容，参考function_template。
预编译 Cf. https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/
#include When you #include a file, the preprocessor replaces the #include directive with the contents of the included file. The included contents are then preprocessed (along with the rest of the file), and then compiled.
Macro defines The #define directive can be used to create a macro. In C++, a macro is a rule that defines how input text is converted into replacement output text.
There are two basic types of macros: object-like macros, and function-like macros. Object-like macros can be defined in one of two ways:
1 2 #define identifier #define identifier substitution_text Object-like macros don’t affect other preprocessor directives 结论：宏展开在预编译指令(Preprocessor directives)无效。
1 2 3 #define PRINT_JOE #ifdef PRINT_JOE // 此处会否将&amp;#39;PRINT_JOE&amp;#39;替换为空呢？ // ... Macros only cause text substitution for normal code. Other preprocessor commands are ignored. Consequently, the PRINT_JOE in #ifdef PRINT_JOE is left alone.
For example:
1 2 3 4 5 #define FOO 9 // Here&amp;#39;s a macro substitution #ifdef FOO // This FOO does not get replaced because it’s part of another preprocessor directive std::cout &amp;lt;&amp;lt; FOO; // This FOO gets replaced with 9 because it&amp;#39;s part of the normal code #endif In actuality, the output of the preprocessor contains no directives at all &amp;ndash; they are all resolved/stripped out before compilation, because the compiler wouldn’t know what to do with them.
The scope of defines Once the preprocessor has finished, all defined identifiers from that file are discarded. This means that directives are only valid from the point of definition to the end of the file in which they are defined. Directives defined in one code file do not have impact on other code files in the same project.
宏定义仅在本文件有效，一旦预编译阶段结束，所有宏都将失效。因为，预编译就是将所有的预编译指令都处理掉，该替换的替换（宏展开），该选择的选择，该丢弃的丢弃（条件编译），然后交给编译器去编译，谨记：编译器是读不懂预编译指令的！
Consider the following example:
function.cpp:
1 2 3 4 5 6 7 8 9 10 11 #include &amp;lt;iostream&amp;gt; void doSomething() { #ifdef PRINT std::cout &amp;lt;&amp;lt; &amp;#34;Printing!&amp;#34;; #endif #ifndef PRINT std::cout &amp;lt;&amp;lt; &amp;#34;Not printing!&amp;#34;; #endif } main.cpp:
1 2 3 4 5 6 7 8 9 void doSomething(); // forward declaration for function doSomething() #define PRINT int main() { doSomething(); return 0; } The above program will print:
Not printing! Even though PRINT was defined in main.cpp, that doesn’t have any impact on any of the code in function.cpp (PRINT is only #defined from the point of definition to the end of main.cpp). This will be of consequence when we discuss header guards in a future lesson.
Header files Cf. https://www.learncpp.com/cpp-tutorial/header-files/
对于多文件项目，文件是单独编译的。要想调用一个自定义函数，linker必须能找到这个函数在哪里定义。
1 2 3 4 5 6 7 int add(int, int); // forward declaration int main() { // add(3, 5); return 0; } 上述文件是可以编译通过的，因为没有发生对add的调用，所以linker不会去找add的定义（当然如果要找也找不到）。
但是如果某处发起了对add的调用（例如去掉注释），那么上述程序在link阶段会报错：
1 2 3 4 yychi@~&amp;gt; clang test_linker.cpp /usr/bin/ld: /tmp/test_linker-e1bb8b.o: in function `main&amp;#39;: test_linker.cpp:(.text+0x1a): undefined reference to `add(int, int)&amp;#39; clang-13: error: linker command failed with exit code 1 (use -v to see invocation) 在多文件编程时，往往需要forawrd declaration，这些前置声明必须在其他某个地方被定义且只被定义一次。这样，linker才能正确的完成链接。任何重复定义或未定义都会在link阶段报错。
考虑如下例子：
add.cpp:
1 2 3 4 int add(int x, int y) { return x + y; } main.cpp:
1 2 3 4 5 6 7 8 9 10 11 #include &amp;lt;stdio.h&amp;gt; int add(int, int); int main() { int x = 1, y = 2; int z = add(x, y); printf(&amp;#34;z=%d\n&amp;#34;, z); return 0; } 在编译main.cpp的时候，因为有add的前置声明，所以可以通过。但为了link的时候能够找到add的定义，add.cpp必须也被编译，所以正确的编译方式应该是：
1 $ clang main.cpp add.cpp Use of header files 从上面的论述我们隐约可见，在多文件编程中，我们可能会大量的使用前置声明（forward declaration），一旦文件多起来，这将非常枯燥。所以头文件的出现就是为了解决这个问题：把所有的声明放在一起。
Let’s write a header file to relieve us of this burden. Writing a header file is surprisingly easy, as header files only consist of two parts:
A header guard. The actual content of the header file, which should be the forward declarations for all of the identifiers we want other files to be able to see. add.h:
1 2 3 4 // 1) We really should have a header guard here, but will omit it for simplicity (we&amp;#39;ll cover header guards in the next lesson) // 2) This is the content of the .h file, which is where the declarations go int add(int x, int y); // function prototype for add.h -- don&amp;#39;t forget the semicolon! main.cpp:
1 2 3 4 5 6 7 8 #include &amp;#34;add.h&amp;#34; // Insert contents of add.h at this point. Note use of double quotes here. #include &amp;lt;iostream&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;The sum of 3 and 4 is &amp;#34; &amp;lt;&amp;lt; add(3, 4) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; return 0; } add.cpp:
1 2 3 4 5 6 #include &amp;#34;add.h&amp;#34; // Insert contents of add.h at this point. Note use of double quotes here. int add(int x, int y) { return x + y; } When the preprocessor processes the #include &amp;quot;add.h&amp;quot; line, it copies the contents of add.h into the current file at that point. Because our add.h contains a forward declaration for function add, that forward declaration will be copied into main.cpp. The end result is a program that is functionally the same as the one where we manually added the forward declaration at the top of main.cpp.
Consequently, our program will compile and link correctly. Two wrong cases 如上图所示，会产生一个重复定义的错误。由于add.h中包含了函数定义，而非前置声明。编译main.cpp的时候，add.h中的代码插入到main.cpp中，产生一次add函数的定义。同理，编译add.cpp的时候也定义了一次add函数。link阶段会发生歧义，以致报错。
此时如果不编译add.cpp其实是可行的： 但谁又能保证只有一个文件#include &amp;quot;add.h&amp;quot;呢？所以头文件中应该只包含声明，而不应该包含实现。
The primary purpose of a header file is to propagate declarations to code files.
Key insight: Header files allow us to put declarations in one location and then import them wherever we need them. This can save a lot of typing in multi-file programs.
Header files should generally not contain function and variable definitions, so as not to violate the one definition rule. An exception is made for symbolic constants (which we cover in lesson 4.15 &amp;ndash; Symbolic constants: const and constexpr variables).
标准库自动链接
注意：clang不会自动链接，需要手动链接 clang main.cpp -lstdc++
When it comes to functions and variables, it’s worth keeping in mind that header files typically only contain function and variable declarations, not function and variable definitions (otherwise a violation of the one definition rule could result). std::cout is forward declared in the iostream header, but defined as part of the C++ standard library, which is automatically linked into your program during the linker phase.
The #include order of header files
Cf. https://www.learncpp.com/cpp-tutorial/header-files/ for &amp;ldquo;the #inclue order of header files&amp;rdquo;.
A view of memory and fundamental data types in cpp Cf. https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/
The smallest unit of memory is a binary digit (also called a bit), which can hold a value of 0 or 1. You can think of a bit as being like a traditional light switch &amp;ndash; either the light is off (0), or it is on (1). There is no in-between. If you were to look at a random segment of memory, all you would see is …011010100101010… or some combination thereof.
Memory is organized into sequential units called memory addresses (or addresses for short). Similar to how a street address can be used to find a given house on a street, the memory address allows us to find and access the contents of memory at a particular location.
Perhaps surprisingly, in modern computer architectures, each bit does not get its own unique memory address. This is because the number of memory addresses are limited, and the need to access data bit-by-bit is rare. Instead, each memory address holds 1 byte of data. A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.
Data types
Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way. You have already seen one example of a data type: the integer. When we declare a variable as an integer, we are telling the compiler “the piece of memory that this variable uses is going to be interpreted as an integer value”.
When you give an object a value, the compiler and CPU take care of encoding your value into the appropriate sequence of bits for that data type, which are then stored in memory (remember: memory can only store bits). For example, if you assign an integer object the value 65, that value is converted to the sequence of bits 0100 0001 and stored in the memory assigned to the object.
Conversely, when the object is evaluated to produce a value, that sequence of bits is reconstituted back into the original value. Meaning that 0100 0001 is converted back into the value 65.
Fortunately, the compiler and CPU do all the hard work here, so you generally don’t need to worry about how values get converted into bit sequences and back.
All you need to do is pick a data type for your object that best matches your desired use.
谨记：内存只能存bit，只能寻址寻到byte这一层，如果数据按内存边界对齐，寻址会更快（一次读）。
由于内存地址空间有限，且按bit寻址的场景很少，所以寻址单位一般是byte。A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.
移位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include &amp;lt;cstdint&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; static void print(int32_t a, uint32_t b, size_t n_shift) { cout &amp;lt;&amp;lt; &amp;#34;a=&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34;; b=&amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;left shift &amp;#34; &amp;lt;&amp;lt; n_shift &amp;lt;&amp;lt; &amp;#34; bit(s) of a is: &amp;#34; &amp;lt;&amp;lt; (a &amp;lt;&amp;lt; n_shift) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;left shift &amp;#34; &amp;lt;&amp;lt; n_shift &amp;lt;&amp;lt; &amp;#34; bit(s) of b is: &amp;#34; &amp;lt;&amp;lt; (b &amp;lt;&amp;lt; n_shift) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;right shift &amp;#34; &amp;lt;&amp;lt; n_shift &amp;lt;&amp;lt; &amp;#34; bit(s) of a is: &amp;#34; &amp;lt;&amp;lt; (a &amp;gt;&amp;gt; n_shift) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;right shift &amp;#34; &amp;lt;&amp;lt; n_shift &amp;lt;&amp;lt; &amp;#34; bit(s) of b is: &amp;#34; &amp;lt;&amp;lt; (b &amp;gt;&amp;gt; n_shift) &amp;lt;&amp;lt; endl; } int main() { int32_t a = 0xffffffff; uint32_t b = 0xffffffff; print(a, b, 1); cout &amp;lt;&amp;lt; &amp;#34;------------\n&amp;#34;; print(0xbfffffff, b, 1); return 0; } /** * Output on my machine: a=-1; b=4294967295 left shift 1 bit(s) of a is: -2 left shift 1 bit(s) of b is: 4294967294 right shift 1 bit(s) of a is: -1 right shift 1 bit(s) of b is: 2147483647 ------------ a=-1073741825; b=4294967295 left shift 1 bit(s) of a is: 2147483646 left shift 1 bit(s) of b is: 4294967294 right shift 1 bit(s) of a is: -536870913 right shift 1 bit(s) of b is: 2147483647 */ 从内存连续bit来看，a和b都是存了4 byte的1，区别仅仅是data type不一样，导致了截然不同的结果。
移位操作
右移 无符号右移，低位丢失高位补0 有符号右移，低位丢失，高位补符号位（正为0, 负为1） 左移：高位丢失，低位补0 a和b左移一位都得到：
0xfffffffe: 如果是int解释为-2, unsigned int解释为4294967294=2^32 - 2 a右移一位得到
0xffffffff: 注意负数右移，高位补1，int解释为-1 b右移一位得到
0x7fffffff: 高位补0, unsigned int解释为2147483647=2^31-1 注意，负的可能左移成正的，因此，有符号的移位是不安全的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &amp;lt;iostream&amp;gt; int main() { signed int s { -1 }; unsigned int u { 1 }; if (s &amp;lt; u) // -1 is implicitly converted to 4294967295, and 4294967295 &amp;lt; 1 is false std::cout &amp;lt;&amp;lt; &amp;#34;-1 is less than 1\n&amp;#34;; else std::cout &amp;lt;&amp;lt; &amp;#34;1 is less than -1\n&amp;#34;; // this statement executes return 0; } NOTE:
注意无符号数相减得负数会导致溢出 usigned和--运算符，可能减至负数溢出 除非确定变量值非负，否则尽量避免使用unsigned 切忌不要在数学计算中混用unsigned和signed，此时signed会隐式转换为unsigned unsigned numbers are preferred when dealing with bit manipulation std::int8_t和std::uint8_t可能知识char和unsigned char的别名，可能有坑（参考：https://www.learncpp.com/cpp-tutorial/introduction-to-type-conversion-and-static_cast/） Best practice
Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.
字节序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * This file test the endian of your machine: * big-endian or little-endian, by visiting * the memory sequentially byte by byte of * a intendly constructed integer. */ #include &amp;lt;cstdint&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; static void print(void* ptr, size_t size) { // convert to char* so we can visit the memory byte by byte unsigned char* _ptr = static_cast&amp;lt;unsigned char*&amp;gt;(ptr); // print the value of each byte in ptr for (size_t i = 0; i &amp;lt; size; ++i) cout &amp;lt;&amp;lt; static_cast&amp;lt;int&amp;gt;(_ptr[i]); cout &amp;lt;&amp;lt; endl; } int main() { uint32_t a = 0x01020304; /* * if it prints 4321, indicates 低位在前，对应little-endian * it it prints 1234, indicates 高位在前，对应big-endian */ print(&amp;amp;a, 4); return 0; } /** * Output on my machine 4321 */ 字节序就是计算机存储数据的时候将低位数据存在低位地址还是高位地址。举个例子，数值0x2211使用两个字节储存：高位字节是0x22，低位字节是0x11。
大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。 小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。 如果太多记不住，至少要记住：
字节序的概念: 读一段内存从低位向高位读（从左往右），先读到高位字节还是低位字节 符合人类读写数值的方法是大端序（big-endian） 既然如此，我们要判断一台机器是big-endian还是little-endian，只需要构造一端内存，按字节从低位地址向高位地址访问，看看低位地址存的是高位字节，还是低位字节即可。
且看上述代码，构造了一个整数0x01020304，然后通过将首地址转成char*的方式去按字节读取内存中的值（这样做的目的是，char*可以逐字节的读取内存；而int*一次指针移动会移动sizeof(int)个字节）。读出来如果是符合书写习惯的1234, 则表明机器是big-endian, 反之little-endian.
这也是一段内存的两种不同的解释方式，recall that Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way.
链接（Linkage） Cf. https://www.learncpp.com/cpp-tutorial/internal-linkage/
Identifiers have another property named linkage. An identifier’s linkage determines whether other declarations of that name refer to the same object or not.
Local variables have no linkage, which means that each declaration refers to a unique object.
Global variable and functions identifiers can have either internal linkage or external linkage.
An identifier with internal linkage can be seen and used within a single file, but it is not accessible from other files (that is, it is not exposed to the linker). This means that if two files have identically named identifiers with internal linkage, those identifiers will be treated as independent.
To make a non-constant global variable internal, we use the static keyword.
1 2 3 4 5 6 7 8 9 static int g_x; // non-constant globals have external linkage by default, but can be given internal linkage via the static keyword const int g_y { 1 }; // const globals have internal linkage by default constexpr int g_z { 2 }; // constexpr globals have internal linkage by default int main() { return 0; } To see it, we take
a.cpp:
1 2 3 int g_x = 22; const int g_y = 33; constexpr int g_z = 44; main.cpp:
1 2 3 4 5 6 7 8 9 10 11 #include &amp;lt;stdio.h&amp;gt; int g_x = 222; const int g_y = 333; constexpr int g_z = 444; int main() { printf(&amp;#34;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&amp;#34;, g_x, g_y, g_z); return 0; } if we compile only main.cpp, it works fine and outputs:
glabal variable (g_x, g_y, g_z) is (222, 333, 444) But if we compile both, it gets
1 2 3 $ clang main.cpp a.cpp /usr/bin/ld: /tmp/a-ea4f54.o:(.data+0x0): multiple definition of `g_x&amp;#39;; /tmp/main-c44eb4.o:(.data+0x0): first defined here clang-13: error: linker command failed with exit code 1 (use -v to see invocation) As we sligtly modify main.cpp:
1 2 3 4 5 6 7 8 9 10 11 #include &amp;lt;stdio.h&amp;gt; extern int g_x; const int g_y = 333; constexpr int g_z = 444; int main() { printf(&amp;#34;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&amp;#34;, g_x, g_y, g_z); return 0; } it&amp;rsquo;s compiled and linked properly with the output:
glabal variable (g_x, g_y, g_z) is (22, 333, 444) noting that the g_x has the value 22 which is defined in a.cpp, we find out the global non-const variable has external linkage. And the properly compilation and linking show that global const has internal linkage.
External linkage Cf. https://www.learncpp.com/cpp-tutorial/external-linkage/
An identifier with external linkage can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration). In this sense, identifiers with external linkage are truly “global” in that they can be used anywhere in your program!
Functions have external linkage by default
In order to call a function defined in another file, you must place a forward declaration for the function in any other files wishing to use the function. The forward declaration tells the compiler about the existence of the function, and the linker connects the function calls to the actual function definition.
Global variables with external linkage
Global variables with external linkage are sometimes called external variables. To make a global variable external (and thus accessible by other files), we can use the extern keyword to do so:
1 2 3 4 5 6 7 8 9 int g_x { 2 }; // non-constant globals are external by default extern const int g_y { 3 }; // const globals can be defined as extern, making them external extern constexpr int g_z { 3 }; // constexpr globals can be defined as extern, making them external (but this is useless, see the note in the next section) int main() { return 0; } Non-const global variables are external by default (if used, the extern keyword will be ignored).
To actually use an external global variable that has been defined in another file, you also must place a forward declaration for the global variable in any other files wishing to use the variable. For variables, creating a forward declaration is also done via the extern keyword (with no initialization value).
Here is an example of using a variable forward declaration:
a.cpp:
1 2 3 // global variable definitions int g_x { 2 }; // non-constant globals have external linkage by default extern const int g_y { 3 }; // this extern gives g_y external linkage main.cpp:
1 2 3 4 5 6 7 8 9 10 #include &amp;lt;iostream&amp;gt; extern int g_x; // this extern is a forward declaration of a variable named g_x that is defined somewhere else extern const int g_y; // this extern is a forward declaration of a const variable named g_y that is defined somewhere else int main() { std::cout &amp;lt;&amp;lt; g_x; // prints 2 return 0; } Note that the extern keyword has different meanings in different contexts. In some contexts, extern means “give this variable external linkage”. In other contexts, extern means “this is a forward declaration for an external variable that is defined somewhere else”.
Summary
Scope determines where a variable is accessible. Duration determines where a variable is created and destroyed. Linkage determines whether the variable can be exported to another file or not.
Inline function 考虑如下场景，有一段代码很独立，适合抽成一个函数，但你又担心函数调用开销，此时inline function就是你的最佳选择。关于合适使用inline function，下面这段话给了一定的意见：
For functions that are large and/or perform complex tasks, the overhead of the function call is typically insignificant compared to the amount of time the function takes to run. However, for small functions, the overhead costs can be larger than the time needed to actually execute the function’s code! In cases where a small function is called often, using a function can result in a significant performance penalty over writing the same code in-place.
Inline function的好处包括：
没有函数调用的开销 编译器对展开后的代码有更大的优化空间（如常量替换） However, inline expansion has its own potential cost: if the body of the function being expanded takes more instructions than the function call being replaced, then each inline expansion will cause the executable to grow larger. Larger executables tend to be slower (due to not fitting as well in caches).
注意：inline只是对编译器的一个建议，是否会真的展开取决于编译器的优化策略。
However, in modern C++, the inline keyword is no longer used to request that a function be expanded inline. There are quite a few reasons for this:
Using inline to request inline expansion is a form of premature optimization, and misuse could actually harm performance. The inline keyword is just a hint &amp;ndash; the compiler is completely free to ignore a request to inline a function. This is likely to be the result if you try to inline a lengthy function! The compiler is also free to perform inline expansion of functions that do not use the inline keyword as part of its normal set of optimizations. The inline keyword is defined at the wrong level of granularity. We use the inline keyword on a function declaration, but inline expansion is actually determined per function call. It may be beneficial to expand some function calls and detrimental to expand others, and there is no syntax to affect this. 注意：在modern cpp中，用inline修饰的不违反ODR（one definition rule），因此可用于
头文件中修饰常量作为global const的最佳方案1 头文件中修饰constexpr函数2使所有include该文件的源文件都能使用该函数，注意constexpr函数是默认inline的 Allowing functions with a constexpr return type to be evaluated at either compile-time or runtime was allowed so that a single function can serve both cases. Otherwise, you’d need to have separate functions (a constexpr version and a non-constexpr version) &amp;ndash; and since return type isn’t considered in function overload resolution, you’d have to name the functions different things!
A constexpr function that is eligible to be evaluated at compile-time will only be evaluated at compile-time if the return value is used where a constant expression is required. Otherwise, compile-time evaluation is not guaranteed.
Thus, a constexpr function is better thought of as “can be used in a constant expression”, not “will be evaluated at compile-time”.
Unnamed namespace An unnamed namespace (also called an anonymous namespace) is a namespace that is defined without a name, like so:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &amp;lt;iostream&amp;gt; namespace // unnamed namespace { void doSomething() // can only be accessed in this file { std::cout &amp;lt;&amp;lt; &amp;#34;v1\n&amp;#34;; } } int main() { doSomething(); // we can call doSomething() without a namespace prefix return 0; } 特点：
All content declared in an unnamed namespace is treated as if it is part of the parent namespace. All identifiers inside an unnamed namespace are treated as if they had internal linkage. 解决的问题：Unnamed namespaces will also keep user-defined types (something we’ll discuss in a later lesson) local to the file, something for which there is no alternative equivalent mechanism to do.
About switch clause
Put another way, defining a variable without an initializer is just telling the compiler that the variable is now in scope from that point on. This happens at compile time, and doesn’t require the definition to actually be executed at runtime.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int calculate(int x, int y, char op) { int ret = 0; switch (op) { case &amp;#39;+&amp;#39;: return x + y; case &amp;#39;-&amp;#39;: return x - y; case &amp;#39;*&amp;#39;: return x * y; case &amp;#39;/&amp;#39;: return x / y; case &amp;#39;%&amp;#39;: return x % y; default: throw std::invalid_arguments(&amp;#34;invalid operator&amp;#34;); } } Pointer to functions The syntax for creating a non-const function pointer is one of the ugliest things you will ever see in C++:
// fcnPtr is a pointer to a function that takes no arguments and returns an integer int (*fcnPtr)(); In the above snippet, fcnPtr is a pointer to a function that has no parameters and returns an integer. fcnPtr can point to any function that matches this type.
To make a const function pointer, the const goes after the asterisk:
int (*const fcnPtr)(); If you put the const before the int, then that would indicate the function being pointed to would return a const int.
"><meta name=keywords content="水阙,yychi"><meta name=generator content="Hugo 0.112.3 with theme even"><link rel=canonical href=https://guyueshui.github.io/post/cpp-learn/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.4db6eefa019323deeb0f96ac97b0195c6875d5cb6a98e30c1e245d54b43d54bc.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=/css/even-custom.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&family=Noto+Serif+SC:wght@400;500;700&display=swap" rel=stylesheet><meta property="og:title" content="C++ 学习笔记"><meta property="og:description" content="诚如是，Life is too short to learn c++. 此篇记录一些我在学习cpp过程中遇到的一些知识点，仅作记录并梳理之效。里面可能会有大量参考其他网络博客，如有侵权，请联系我删除之。
Reactor v.s. Proactor

epll/wait: reactor模式，不停轮询，发现有事做，就做！
asio: proactor模式，先注册好事件，如果事情发生了，通过回调函数处理。

几个常用的宏

__func__: name of an function, exists in C99/C++11 (__FUNCTION__ is non standard)
__LINE__: line number of the code
__FILE__: filename of the file
__DATE__ and __TIME__: as you wish

不要在ctor里调用虚函数
总结来说：基类部分在派生类部分之前被构造，当基类构造函数执行时派生类中的数据成员还没被初始化。如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug。
ctor应该设计的尽量简单，确保对象可以被正确构造。在ctor中调用本类的非静态成员都是不安全的，因为他们还没被构造，而有些成员是依赖对象的，而此时对象还没有被成功构造。
ctor不能是虚函数


从存储空间角度：虚函数对应一个vtable（虚函数表），这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。


从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。
虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。


构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。


——————————————————
版权声明：本文为CSDN博主「cainiao000001」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/cainiao000001/article/details/81603782
虚函数的工作原理
https://zhuanlan.zhihu.com/p/60543586
C++ 规定了虚函数的行为，但将实现方法留给了编译器的作者。不需要知道实现方法也可以很好的使用虚函数，但了解虚函数的工作原理有助于更好地理解概念。
通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。
这种数组称为虚函数表（Virtual Function Table, vtbl）。
虚函数表是一个数组，数组的元素是指针，指针指的是虚函数的地址。
具有虚函数的类的实例，都会在头部存一个指向虚函数表的指针。
常见类型所占空间大小



TYPE
Bytes




(unsigned) int
4


(unsigned) short
2


(unsigned) long
8


float
4


double
8


long double
16


(unsigned) char
1


bool
1



指针占几个字节 指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关，譬如以前是16为地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就为8个字节。

NOTE: 类成员函数指针一般为普通指针的两倍大小。

literal 5.0类型为double，5.0f类型为float。不加f后缀默认double.
静态成员的初始化
当一个类包含静态成员时，最好的做法是在类中声明，在类外初始化。由于静态成员是所有对象共享的，如果在类内初始化，则每个对象构造时，都要执行一遍静态成员的初始化，这无疑是一种浪费。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


struct A
{
  static int a;
  int b;
  void fun();
  ...
};

int A::a = 233;

class B
{
public:
  void fun();
  ...
private:
  static string str_;
  bool done_;
};

string B::str_ = &#34;hello, i am static&#34;;


析构函数的调用时机
The destructor is called whenever an object&rsquo;s lifetime ends, which includes

program termination, for objects with static storage duration
thread exit, for objects with thread-local storage duration
end of scope, for objects with automatic storage duration and for temporaries whose life was extended by binding to reference
delete-expressin, for objects with dynamic storage duration
end of the full expression, for nameless temporaries
stack unwinding (栈回溯), for objects with automatic storage duration when an exception escapes their block, uncaught.

cf. https://en.cppreference.com/w/cpp/language/destructor
常量
Literal constants
字面值常量
Cf. https://www.learncpp.com/cpp-tutorial/literals/
Symbolic constants
符号常量
Cf. https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/

Const variables must be initialized
Function parameters for arguments passed by value should not be made const.
Don’t use const with return by value.

Runtime vs compile-time constants
Runtime constants are constants whose initialization values can only be resolved at runtime (when your program is running). The following are examples of runtime constants:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20


#include <iostream>

void printInt(const int x) // x is a runtime constant because the value isn't known until the program is run
{
    std::cout << x;
}

int main()
{
    std::cout << &#34;Enter your age: &#34;;
    int age{};
    std::cin >> age;

    const int usersAge { age }; // usersAge is a runtime constant because the value isn't known until the program is run

    std::cout << &#34;Your age is: &#34;;
    printInt(age);

    return 0;
}


Compile-time constants are constants whose initialization values can be determined at compile-time (when your program is compiling). The following are examples of compile-time constants:


1
2


const double gravity { 9.8 }; // the compiler knows at compile-time that gravity will have value 9.8
const int something { 1 + 2 }; // the compiler can resolve this at compiler time


Compile-time constants enable the compiler to perform optimizations that aren’t available with runtime constants. For example, whenever gravity is used, the compiler can simply substitute the identifier gravity with the literal double 9.8.
To help provide more specificity, C++11 introduced the keyword constexpr, which ensures that a constant must be a compile-time constant.

Any variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as constexpr.
Any variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as const.

Note that literals are also implicitly constexpr, as the value of a literal is known at compile-time.
A constant expression is an expression that can be evaluated at compile-time. For example:


1
2
3
4
5
6


#include <iostream>
int main()
{
	std::cout << 3 + 4; // 3 + 4 evaluated at compile-time
	return 0;
}


In the above program, because the literal values 3 and 4 are known at compile-time, the compiler can evaluate the expression 3 + 4 at compile-time and substitute in the resulting value 7. That makes the code faster because 3 + 4 no longer has to be calculated at runtime.
Constexpr variables can also be used in constant expressions:


1
2
3
4
5
6
7
8


#include <iostream>
int main()
{
	constexpr int x { 3 };
	constexpr int y { 4 };
	std::cout << x + y; // x + y evaluated at compile-time
	return 0;
}


In the above example, because x and y are constexpr, the expression x + y is a constant expression that can be evaluated at compile-time. Similar to the literal case, the compiler can substitute in the value 7.
Object-like preprocessor macros v.s. symbolic constants
Object-like macro has the form:


1


#define identifier substitution_text


Whenever the preprocessor encounters this directive, any further occurrence of identifier is replaced by substitution_text. The identifier is traditionally typed in all capital letters, using underscores to represent spaces.

Avoid using #define to create symbolic constants macros. Use const or constexpr variables instead.

Macros can have naming conflicts with normal code. For example:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


#include &#34;someheader.h&#34;
#include <iostream>

int main()
{
    int beta { 5 };
    std::cout << beta;

    return 0;
}


If someheader.h happened to #define a macro named beta, this simple program would break, as the preprocessor would replace the int variable beta’s name with whatever the macro’s value was. This is normally avoided by using all caps for macro names, but it can still happen.
Using symbolic constants throughout a multi-file program
Cf. https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/
内存布局
结构体
C++规范在“结构”上使用了和C相同的，简单的内存布局原则：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


struct S {
    char a;     // memory location #1
    int b : 5;  // memory location #2
    int c : 11, // memory location #2 (continued)
    char  : 0,
    int d : 8;  // memory location #3
    struct {
        int ee : 8; // memory location #4
    } e;
} obj; // The object 'obj' consists of 4 separate memory locations



类的静态成员不占用类的空间，静态成员在程序数据段中。

对齐
Cf. https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/#comment-563585
Cf. http://www.catb.org/esr/structure-packing/
模板
重载与特化
从编译到函数模板的调用，编译器必须在非模板重载、模板重载和模板重载的特化间决定。


1
2
3
4
5
6
7
8
9


template< class T > void f(T);              // #1 ：模板重载
template< class T > void f(T*);             // #2 ：模板重载
void                     f(double);         // #3 ：非模板重载
template<>          void f(int);            // #4 ： #1 的特化

f('a');        // 调用 #1
f(new int(1)); // 调用 #2
f(1.0);        // 调用 #3
f(1);          // 调用 #4


注意只有非模板和初等模板重载参与重载决议。特化不是重载，且不受考虑。只有在重载决议选择最佳匹配初等函数模板后，才检验其特化以查看何为最佳匹配。


1
2
3
4
5


template< class T > void f(T);    // #1 ：所有类型的重载
template<>          void f(int*); // #2 ：为指向 int 的指针特化 #1
template< class T > void f(T*);   // #3 ：所有指针类型的重载

f(new int(1)); // 调用 #3 ，即使通过 #1 的特化会是完美匹配


即重载的优先级要高于特化。
关于模板函数重载的更多内容，参考function_template。
预编译
Cf. https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/
#include
When you #include a file, the preprocessor replaces the #include directive with the contents of the included file. The included contents are then preprocessed (along with the rest of the file), and then compiled.
Macro defines
The #define directive can be used to create a macro. In C++, a macro is a rule that defines how input text is converted into replacement output text.
There are two basic types of macros: object-like macros, and function-like macros.
Object-like macros can be defined in one of two ways:


1
2


#define identifier
#define identifier substitution_text


Object-like macros don’t affect other preprocessor directives
结论：宏展开在预编译指令(Preprocessor directives)无效。


1
2
3


#define PRINT_JOE
#ifdef PRINT_JOE    // 此处会否将'PRINT_JOE'替换为空呢？
// ...


Macros only cause text substitution for normal code. Other preprocessor commands are ignored. Consequently, the PRINT_JOE in #ifdef PRINT_JOE is left alone.
For example:


1
2
3
4
5


#define FOO 9 // Here's a macro substitution

#ifdef FOO // This FOO does not get replaced because it’s part of another preprocessor directive
    std::cout << FOO; // This FOO gets replaced with 9 because it's part of the normal code
#endif


In actuality, the output of the preprocessor contains no directives at all &ndash; they are all resolved/stripped out before compilation, because the compiler wouldn’t know what to do with them.
The scope of defines
Once the preprocessor has finished, all defined identifiers from that file are discarded. This means that directives are only valid from the point of definition to the end of the file in which they are defined. Directives defined in one code file do not have impact on other code files in the same project.
宏定义仅在本文件有效，一旦预编译阶段结束，所有宏都将失效。因为，预编译就是将所有的预编译指令都处理掉，该替换的替换（宏展开），该选择的选择，该丢弃的丢弃（条件编译），然后交给编译器去编译，谨记：编译器是读不懂预编译指令的！
Consider the following example:
function.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


#include <iostream>

void doSomething()
{
#ifdef PRINT
    std::cout << &#34;Printing!&#34;;
#endif
#ifndef PRINT
    std::cout << &#34;Not printing!&#34;;
#endif
}


main.cpp:


1
2
3
4
5
6
7
8
9


void doSomething(); // forward declaration for function doSomething()

#define PRINT

int main()
{
    doSomething();
    return 0;
}


The above program will print:
Not printing!
Even though PRINT was defined in main.cpp, that doesn’t have any impact on any of the code in function.cpp (PRINT is only #defined from the point of definition to the end of main.cpp). This will be of consequence when we discuss header guards in a future lesson.
Header files
Cf. https://www.learncpp.com/cpp-tutorial/header-files/
对于多文件项目，文件是单独编译的。要想调用一个自定义函数，linker必须能找到这个函数在哪里定义。


1
2
3
4
5
6
7


int add(int, int);  // forward declaration

int main()
{
    // add(3, 5);
    return 0;
}


上述文件是可以编译通过的，因为没有发生对add的调用，所以linker不会去找add的定义（当然如果要找也找不到）。
但是如果某处发起了对add的调用（例如去掉注释），那么上述程序在link阶段会报错：


1
2
3
4


yychi@~> clang test_linker.cpp
/usr/bin/ld: /tmp/test_linker-e1bb8b.o: in function `main':
test_linker.cpp:(.text+0x1a): undefined reference to `add(int, int)'
clang-13: error: linker command failed with exit code 1 (use -v to see invocation)


在多文件编程时，往往需要forawrd declaration，这些前置声明必须在其他某个地方被定义且只被定义一次。这样，linker才能正确的完成链接。任何重复定义或未定义都会在link阶段报错。
考虑如下例子：
add.cpp:


1
2
3
4


int add(int x, int y)
{
    return x + y;
}


main.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


#include <stdio.h>

int add(int, int);

int main()
{
    int x = 1, y = 2;
    int z = add(x, y);
    printf(&#34;z=%d\n&#34;, z);
    return 0;
}


在编译main.cpp的时候，因为有add的前置声明，所以可以通过。但为了link的时候能够找到add的定义，add.cpp必须也被编译，所以正确的编译方式应该是：


1


$ clang main.cpp add.cpp


Use of header files
从上面的论述我们隐约可见，在多文件编程中，我们可能会大量的使用前置声明（forward declaration），一旦文件多起来，这将非常枯燥。所以头文件的出现就是为了解决这个问题：把所有的声明放在一起。
Let’s write a header file to relieve us of this burden. Writing a header file is surprisingly easy, as header files only consist of two parts:

A header guard.
The actual content of the header file, which should be the forward declarations for all of the identifiers we want other files to be able to see.

add.h:


1
2
3
4


// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)

// 2) This is the content of the .h file, which is where the declarations go
int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!


main.cpp:


1
2
3
4
5
6
7
8


#include &#34;add.h&#34; // Insert contents of add.h at this point.  Note use of double quotes here.
#include <iostream>

int main()
{
    std::cout << &#34;The sum of 3 and 4 is &#34; << add(3, 4) << '\n';
    return 0;
}


add.cpp:


1
2
3
4
5
6


#include &#34;add.h&#34; // Insert contents of add.h at this point.  Note use of double quotes here.

int add(int x, int y)
{
    return x + y;
}


When the preprocessor processes the #include &#34;add.h&#34; line, it copies the contents of add.h into the current file at that point. Because our add.h contains a forward declaration for function add, that forward declaration will be copied into main.cpp. The end result is a program that is functionally the same as the one where we manually added the forward declaration at the top of main.cpp.
Consequently, our program will compile and link correctly.

Two wrong cases

如上图所示，会产生一个重复定义的错误。由于add.h中包含了函数定义，而非前置声明。编译main.cpp的时候，add.h中的代码插入到main.cpp中，产生一次add函数的定义。同理，编译add.cpp的时候也定义了一次add函数。link阶段会发生歧义，以致报错。
此时如果不编译add.cpp其实是可行的：

但谁又能保证只有一个文件#include &#34;add.h&#34;呢？所以头文件中应该只包含声明，而不应该包含实现。

The primary purpose of a header file is to propagate declarations to code files.

Key insight: Header files allow us to put declarations in one location and then import them wherever we need them. This can save a lot of typing in multi-file programs.
Header files should generally not contain function and variable definitions, so as not to violate the one definition rule. An exception is made for symbolic constants (which we cover in lesson 4.15 &ndash; Symbolic constants: const and constexpr variables).
标准库自动链接

注意：clang不会自动链接，需要手动链接
clang main.cpp -lstdc++

When it comes to functions and variables, it’s worth keeping in mind that header files typically only contain function and variable declarations, not function and variable definitions (otherwise a violation of the one definition rule could result). std::cout is forward declared in the iostream header, but defined as part of the C++ standard library, which is automatically linked into your program during the linker phase.

The #include order of header files
Cf. https://www.learncpp.com/cpp-tutorial/header-files/  for &ldquo;the #inclue order of header files&rdquo;.
A view of memory and fundamental data types in cpp
Cf. https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/
The smallest unit of memory is a binary digit (also called a bit), which can hold a value of 0 or 1. You can think of a bit as being like a traditional light switch &ndash; either the light is off (0), or it is on (1). There is no in-between. If you were to look at a random segment of memory, all you would see is …011010100101010… or some combination thereof.
Memory is organized into sequential units called memory addresses (or addresses for short). Similar to how a street address can be used to find a given house on a street, the memory address allows us to find and access the contents of memory at a particular location.
Perhaps surprisingly, in modern computer architectures, each bit does not get its own unique memory address. This is because the number of memory addresses are limited, and the need to access data bit-by-bit is rare. Instead, each memory address holds 1 byte of data. A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.
Data types
Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way. You have already seen one example of a data type: the integer. When we declare a variable as an integer, we are telling the compiler “the piece of memory that this variable uses is going to be interpreted as an integer value”.
When you give an object a value, the compiler and CPU take care of encoding your value into the appropriate sequence of bits for that data type, which are then stored in memory (remember: memory can only store bits). For example, if you assign an integer object the value 65, that value is converted to the sequence of bits 0100 0001 and stored in the memory assigned to the object.
Conversely, when the object is evaluated to produce a value, that sequence of bits is reconstituted back into the original value. Meaning that 0100 0001 is converted back into the value 65.
Fortunately, the compiler and CPU do all the hard work here, so you generally don’t need to worry about how values get converted into bit sequences and back.
All you need to do is pick a data type for your object that best matches your desired use.
谨记：内存只能存bit，只能寻址寻到byte这一层，如果数据按内存边界对齐，寻址会更快（一次读）。
由于内存地址空间有限，且按bit寻址的场景很少，所以寻址单位一般是byte。A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.
移位


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40


#include <cstdint>
#include <iostream>
using namespace std;

static void print(int32_t a, uint32_t b, size_t n_shift)
{
    cout << &#34;a=&#34; << a << &#34;; b=&#34; << b << endl;

    cout << &#34;left shift &#34; << n_shift << &#34; bit(s) of a is: &#34; << (a << n_shift) << endl;
    cout << &#34;left shift &#34; << n_shift << &#34; bit(s) of b is: &#34; << (b << n_shift) << endl;
    cout << &#34;right shift &#34; << n_shift << &#34; bit(s) of a is: &#34; << (a >> n_shift) << endl;
    cout << &#34;right shift &#34; << n_shift << &#34; bit(s) of b is: &#34; << (b >> n_shift) << endl;
}

int main()
{
    int32_t a = 0xffffffff;
    uint32_t b = 0xffffffff;
    print(a, b, 1);
    cout << &#34;------------\n&#34;;
    print(0xbfffffff, b, 1);
    return 0;
}

/**
 * Output on my machine:

a=-1; b=4294967295
left shift 1 bit(s) of a is: -2
left shift 1 bit(s) of b is: 4294967294
right shift 1 bit(s) of a is: -1
right shift 1 bit(s) of b is: 2147483647
------------
a=-1073741825; b=4294967295
left shift 1 bit(s) of a is: 2147483646
left shift 1 bit(s) of b is: 4294967294
right shift 1 bit(s) of a is: -536870913
right shift 1 bit(s) of b is: 2147483647

 */


从内存连续bit来看，a和b都是存了4 byte的1，区别仅仅是data type不一样，导致了截然不同的结果。
移位操作

右移

无符号右移，低位丢失高位补0
有符号右移，低位丢失，高位补符号位（正为0, 负为1）


左移：高位丢失，低位补0

a和b左移一位都得到：
0xfffffffe: 如果是int解释为-2, unsigned int解释为4294967294=2^32 - 2
a右移一位得到
0xffffffff: 注意负数右移，高位补1，int解释为-1
b右移一位得到
0x7fffffff: 高位补0, unsigned int解释为2147483647=2^31-1
注意，负的可能左移成正的，因此，有符号的移位是不安全的。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


#include <iostream>

int main()
{
    signed int s { -1 };
    unsigned int u { 1 };

    if (s < u) // -1 is implicitly converted to 4294967295, and 4294967295 < 1 is false
        std::cout << &#34;-1 is less than 1\n&#34;;
    else
        std::cout << &#34;1 is less than -1\n&#34;; // this statement executes

    return 0;
}


NOTE:

注意无符号数相减得负数会导致溢出
usigned和--运算符，可能减至负数溢出
除非确定变量值非负，否则尽量避免使用unsigned
切忌不要在数学计算中混用unsigned和signed，此时signed会隐式转换为unsigned
unsigned numbers are preferred when dealing with bit manipulation
std::int8_t和std::uint8_t可能知识char和unsigned char的别名，可能有坑（参考：https://www.learncpp.com/cpp-tutorial/introduction-to-type-conversion-and-static_cast/）

Best practice
Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.
字节序


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38


/**
 * This file test the endian of your machine:
 * big-endian or little-endian, by visiting
 * the memory sequentially byte by byte of
 * a intendly constructed integer.
 */

#include <cstdint>
#include <stdio.h>
#include <iostream>

using namespace std;

static void print(void* ptr, size_t size)
{
    // convert to char* so we can visit the memory byte by byte
    unsigned char* _ptr = static_cast<unsigned char*>(ptr);
    // print the value of each byte in ptr
    for (size_t i = 0; i < size; ++i)
        cout << static_cast<int>(_ptr[i]);
    cout << endl;
}

int main()
{
    uint32_t a = 0x01020304;
    /*
     * if it prints 4321, indicates 低位在前，对应little-endian
     * it it prints 1234, indicates 高位在前，对应big-endian
     */
    print(&amp;a, 4);
    return 0;
}

/**
 * Output on my machine
4321
 */


字节序就是计算机存储数据的时候将低位数据存在低位地址还是高位地址。举个例子，数值0x2211使用两个字节储存：高位字节是0x22，低位字节是0x11。

大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。
小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。

如果太多记不住，至少要记住：

字节序的概念: 读一段内存从低位向高位读（从左往右），先读到高位字节还是低位字节
符合人类读写数值的方法是大端序（big-endian）

既然如此，我们要判断一台机器是big-endian还是little-endian，只需要构造一端内存，按字节从低位地址向高位地址访问，看看低位地址存的是高位字节，还是低位字节即可。
且看上述代码，构造了一个整数0x01020304，然后通过将首地址转成char*的方式去按字节读取内存中的值（这样做的目的是，char*可以逐字节的读取内存；而int*一次指针移动会移动sizeof(int)个字节）。读出来如果是符合书写习惯的1234, 则表明机器是big-endian, 反之little-endian.
这也是一段内存的两种不同的解释方式，recall that Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way.
链接（Linkage）
Cf. https://www.learncpp.com/cpp-tutorial/internal-linkage/
Identifiers have another property named linkage. An identifier’s linkage determines whether other declarations of that name refer to the same object or not.
Local variables have no linkage, which means that each declaration refers to a unique object.
Global variable and functions identifiers can have either internal linkage or external linkage.
An identifier with internal linkage can be seen and used within a single file, but it is not accessible from other files (that is, it is not exposed to the linker). This means that if two files have identically named identifiers with internal linkage, those identifiers will be treated as independent.
To make a non-constant global variable internal, we use the static keyword.


1
2
3
4
5
6
7
8
9


static int g_x; // non-constant globals have external linkage by default, but can be given internal linkage via the static keyword

const int g_y { 1 }; // const globals have internal linkage by default
constexpr int g_z { 2 }; // constexpr globals have internal linkage by default

int main()
{
    return 0;
}


To see it, we take
a.cpp:


1
2
3


int g_x = 22;
const int g_y = 33;
constexpr int g_z = 44;


main.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


#include <stdio.h>

int g_x = 222;
const int g_y = 333;
constexpr int g_z = 444;

int main()
{
    printf(&#34;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&#34;, g_x, g_y, g_z);
    return 0;
}


if we compile only main.cpp, it works fine and outputs:
glabal variable (g_x, g_y, g_z) is (222, 333, 444)
But if we compile both, it gets


1
2
3


$ clang main.cpp a.cpp
/usr/bin/ld: /tmp/a-ea4f54.o:(.data+0x0): multiple definition of `g_x'; /tmp/main-c44eb4.o:(.data+0x0): first defined here
clang-13: error: linker command failed with exit code 1 (use -v to see invocation)


As we sligtly modify main.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


#include <stdio.h>

extern int g_x;
const int g_y = 333;
constexpr int g_z = 444;

int main()
{
    printf(&#34;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&#34;, g_x, g_y, g_z);
    return 0;
}


it&rsquo;s compiled and linked properly with the output:
glabal variable (g_x, g_y, g_z) is (22, 333, 444)
noting that the g_x has the value 22 which is defined in a.cpp, we find out the global non-const variable has external linkage. And the properly compilation and linking show that global const has internal linkage.
External linkage
Cf. https://www.learncpp.com/cpp-tutorial/external-linkage/
An identifier with external linkage can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration). In this sense, identifiers with external linkage are truly “global” in that they can be used anywhere in your program!
Functions have external linkage by default
In order to call a function defined in another file, you must place a forward declaration for the function in any other files wishing to use the function. The forward declaration tells the compiler about the existence of the function, and the linker connects the function calls to the actual function definition.
Global variables with external linkage
Global variables with external linkage are sometimes called external variables. To make a global variable external (and thus accessible by other files), we can use the extern keyword to do so:


1
2
3
4
5
6
7
8
9


int g_x { 2 }; // non-constant globals are external by default

extern const int g_y { 3 }; // const globals can be defined as extern, making them external
extern constexpr int g_z { 3 }; // constexpr globals can be defined as extern, making them external (but this is useless, see the note in the next section)

int main()
{
    return 0;
}


Non-const global variables are external by default (if used, the extern keyword will be ignored).
To actually use an external global variable that has been defined in another file, you also must place a forward declaration for the global variable in any other files wishing to use the variable. For variables, creating a forward declaration is also done via the extern keyword (with no initialization value).
Here is an example of using a variable forward declaration:
a.cpp:


1
2
3


// global variable definitions
int g_x { 2 }; // non-constant globals have external linkage by default
extern const int g_y { 3 }; // this extern gives g_y external linkage


main.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


#include <iostream>

extern int g_x; // this extern is a forward declaration of a variable named g_x that is defined somewhere else
extern const int g_y; // this extern is a forward declaration of a const variable named g_y that is defined somewhere else

int main()
{
    std::cout << g_x; // prints 2
    return 0;
}


Note that the extern keyword has different meanings in different contexts. In some contexts, extern means “give this variable external linkage”. In other contexts, extern means “this is a forward declaration for an external variable that is defined somewhere else”.
Summary
Scope determines where a variable is accessible. Duration determines where a variable is created and destroyed. Linkage determines whether the variable can be exported to another file or not.
Inline function
考虑如下场景，有一段代码很独立，适合抽成一个函数，但你又担心函数调用开销，此时inline function就是你的最佳选择。关于合适使用inline function，下面这段话给了一定的意见：

For functions that are large and/or perform complex tasks, the overhead of the function call is typically insignificant compared to the amount of time the function takes to run. However, for small functions, the overhead costs can be larger than the time needed to actually execute the function’s code! In cases where a small function is called often, using a function can result in a significant performance penalty over writing the same code in-place.

Inline function的好处包括：

没有函数调用的开销
编译器对展开后的代码有更大的优化空间（如常量替换）

However, inline expansion has its own potential cost: if the body of the function being expanded takes more instructions than the function call being replaced, then each inline expansion will cause the executable to grow larger. Larger executables tend to be slower (due to not fitting as well in caches).

注意：inline只是对编译器的一个建议，是否会真的展开取决于编译器的优化策略。

However, in modern C++, the inline keyword is no longer used to request that a function be expanded inline. There are quite a few reasons for this:

Using inline to request inline expansion is a form of premature optimization, and misuse could actually harm performance.
The inline keyword is just a hint &ndash; the compiler is completely free to ignore a request to inline a function. This is likely to be the result if you try to inline a lengthy function! The compiler is also free to perform inline expansion of functions that do not use the inline keyword  as part of its normal set of optimizations.
The inline keyword is defined at the wrong level of granularity. We use the inline keyword on a function declaration, but inline expansion is actually determined per function call. It may be beneficial to expand some function calls and detrimental to expand others, and there is no syntax to affect this.

注意：在modern cpp中，用inline修饰的不违反ODR（one definition rule），因此可用于

头文件中修饰常量作为global const的最佳方案1
头文件中修饰constexpr函数2使所有include该文件的源文件都能使用该函数，注意constexpr函数是默认inline的


Allowing functions with a constexpr return type to be evaluated at either compile-time or runtime was allowed so that a single function can serve both cases. Otherwise, you’d need to have separate functions (a constexpr version and a non-constexpr version) &ndash; and since return type isn’t considered in function overload resolution, you’d have to name the functions different things!
A constexpr function that is eligible to be evaluated at compile-time will only be evaluated at compile-time if the return value is used where a constant expression is required. Otherwise, compile-time evaluation is not guaranteed.
Thus, a constexpr function is better thought of as “can be used in a constant expression”, not “will be evaluated at compile-time”.

Unnamed namespace
An unnamed namespace (also called an anonymous namespace) is a namespace that is defined without a name, like so:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16


#include <iostream>

namespace // unnamed namespace
{
    void doSomething() // can only be accessed in this file
    {
        std::cout << &#34;v1\n&#34;;
    }
}

int main()
{
    doSomething(); // we can call doSomething() without a namespace prefix

    return 0;
}


特点：

All content declared in an unnamed namespace is treated as if it is part of the parent namespace.
All identifiers inside an unnamed namespace are treated as if they had internal linkage.

解决的问题：Unnamed namespaces will also keep user-defined types (something we’ll discuss in a later lesson) local to the file, something for which there is no alternative equivalent mechanism to do.
About switch clause
Put another way, defining a variable without an initializer is just telling the compiler that the variable is now in scope from that point on. This happens at compile time, and doesn’t require the definition to actually be executed at runtime.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19


int calculate(int x, int y, char op)
{
    int ret = 0;
    switch (op)
    {
    case '+':
        return x + y;
        case '-':
        return x - y;
        case '*':
        return x * y;
        case '/':
        return x / y;
        case '%':
        return x % y;
        default:
        throw std::invalid_arguments(&#34;invalid operator&#34;);
    }
}


Pointer to functions
The syntax for creating a non-const function pointer is one of the ugliest things you will ever see in C++:
// fcnPtr is a pointer to a function that takes no arguments and returns an integer
int (*fcnPtr)();
In the above snippet, fcnPtr is a pointer to a function that has no parameters and returns an integer. fcnPtr can point to any function that matches this type.
To make a const function pointer, the const goes after the asterisk:
int (*const fcnPtr)();
If you put the const before the int, then that would indicate the function being pointed to would return a const int."><meta property="og:type" content="article"><meta property="og:url" content="https://guyueshui.github.io/post/cpp-learn/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-08-28T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-28T21:47:34+08:00"><meta itemprop=name content="C++ 学习笔记"><meta itemprop=description content="诚如是，Life is too short to learn c++. 此篇记录一些我在学习cpp过程中遇到的一些知识点，仅作记录并梳理之效。里面可能会有大量参考其他网络博客，如有侵权，请联系我删除之。
Reactor v.s. Proactor

epll/wait: reactor模式，不停轮询，发现有事做，就做！
asio: proactor模式，先注册好事件，如果事情发生了，通过回调函数处理。

几个常用的宏

__func__: name of an function, exists in C99/C++11 (__FUNCTION__ is non standard)
__LINE__: line number of the code
__FILE__: filename of the file
__DATE__ and __TIME__: as you wish

不要在ctor里调用虚函数
总结来说：基类部分在派生类部分之前被构造，当基类构造函数执行时派生类中的数据成员还没被初始化。如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug。
ctor应该设计的尽量简单，确保对象可以被正确构造。在ctor中调用本类的非静态成员都是不安全的，因为他们还没被构造，而有些成员是依赖对象的，而此时对象还没有被成功构造。
ctor不能是虚函数


从存储空间角度：虚函数对应一个vtable（虚函数表），这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。


从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。
虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。


构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。


——————————————————
版权声明：本文为CSDN博主「cainiao000001」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/cainiao000001/article/details/81603782
虚函数的工作原理
https://zhuanlan.zhihu.com/p/60543586
C++ 规定了虚函数的行为，但将实现方法留给了编译器的作者。不需要知道实现方法也可以很好的使用虚函数，但了解虚函数的工作原理有助于更好地理解概念。
通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。
这种数组称为虚函数表（Virtual Function Table, vtbl）。
虚函数表是一个数组，数组的元素是指针，指针指的是虚函数的地址。
具有虚函数的类的实例，都会在头部存一个指向虚函数表的指针。
常见类型所占空间大小



TYPE
Bytes




(unsigned) int
4


(unsigned) short
2


(unsigned) long
8


float
4


double
8


long double
16


(unsigned) char
1


bool
1



指针占几个字节 指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关，譬如以前是16为地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就为8个字节。

NOTE: 类成员函数指针一般为普通指针的两倍大小。

literal 5.0类型为double，5.0f类型为float。不加f后缀默认double.
静态成员的初始化
当一个类包含静态成员时，最好的做法是在类中声明，在类外初始化。由于静态成员是所有对象共享的，如果在类内初始化，则每个对象构造时，都要执行一遍静态成员的初始化，这无疑是一种浪费。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


struct A
{
  static int a;
  int b;
  void fun();
  ...
};

int A::a = 233;

class B
{
public:
  void fun();
  ...
private:
  static string str_;
  bool done_;
};

string B::str_ = &#34;hello, i am static&#34;;


析构函数的调用时机
The destructor is called whenever an object&rsquo;s lifetime ends, which includes

program termination, for objects with static storage duration
thread exit, for objects with thread-local storage duration
end of scope, for objects with automatic storage duration and for temporaries whose life was extended by binding to reference
delete-expressin, for objects with dynamic storage duration
end of the full expression, for nameless temporaries
stack unwinding (栈回溯), for objects with automatic storage duration when an exception escapes their block, uncaught.

cf. https://en.cppreference.com/w/cpp/language/destructor
常量
Literal constants
字面值常量
Cf. https://www.learncpp.com/cpp-tutorial/literals/
Symbolic constants
符号常量
Cf. https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/

Const variables must be initialized
Function parameters for arguments passed by value should not be made const.
Don’t use const with return by value.

Runtime vs compile-time constants
Runtime constants are constants whose initialization values can only be resolved at runtime (when your program is running). The following are examples of runtime constants:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20


#include <iostream>

void printInt(const int x) // x is a runtime constant because the value isn't known until the program is run
{
    std::cout << x;
}

int main()
{
    std::cout << &#34;Enter your age: &#34;;
    int age{};
    std::cin >> age;

    const int usersAge { age }; // usersAge is a runtime constant because the value isn't known until the program is run

    std::cout << &#34;Your age is: &#34;;
    printInt(age);

    return 0;
}


Compile-time constants are constants whose initialization values can be determined at compile-time (when your program is compiling). The following are examples of compile-time constants:


1
2


const double gravity { 9.8 }; // the compiler knows at compile-time that gravity will have value 9.8
const int something { 1 + 2 }; // the compiler can resolve this at compiler time


Compile-time constants enable the compiler to perform optimizations that aren’t available with runtime constants. For example, whenever gravity is used, the compiler can simply substitute the identifier gravity with the literal double 9.8.
To help provide more specificity, C++11 introduced the keyword constexpr, which ensures that a constant must be a compile-time constant.

Any variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as constexpr.
Any variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as const.

Note that literals are also implicitly constexpr, as the value of a literal is known at compile-time.
A constant expression is an expression that can be evaluated at compile-time. For example:


1
2
3
4
5
6


#include <iostream>
int main()
{
	std::cout << 3 + 4; // 3 + 4 evaluated at compile-time
	return 0;
}


In the above program, because the literal values 3 and 4 are known at compile-time, the compiler can evaluate the expression 3 + 4 at compile-time and substitute in the resulting value 7. That makes the code faster because 3 + 4 no longer has to be calculated at runtime.
Constexpr variables can also be used in constant expressions:


1
2
3
4
5
6
7
8


#include <iostream>
int main()
{
	constexpr int x { 3 };
	constexpr int y { 4 };
	std::cout << x + y; // x + y evaluated at compile-time
	return 0;
}


In the above example, because x and y are constexpr, the expression x + y is a constant expression that can be evaluated at compile-time. Similar to the literal case, the compiler can substitute in the value 7.
Object-like preprocessor macros v.s. symbolic constants
Object-like macro has the form:


1


#define identifier substitution_text


Whenever the preprocessor encounters this directive, any further occurrence of identifier is replaced by substitution_text. The identifier is traditionally typed in all capital letters, using underscores to represent spaces.

Avoid using #define to create symbolic constants macros. Use const or constexpr variables instead.

Macros can have naming conflicts with normal code. For example:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


#include &#34;someheader.h&#34;
#include <iostream>

int main()
{
    int beta { 5 };
    std::cout << beta;

    return 0;
}


If someheader.h happened to #define a macro named beta, this simple program would break, as the preprocessor would replace the int variable beta’s name with whatever the macro’s value was. This is normally avoided by using all caps for macro names, but it can still happen.
Using symbolic constants throughout a multi-file program
Cf. https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/
内存布局
结构体
C++规范在“结构”上使用了和C相同的，简单的内存布局原则：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


struct S {
    char a;     // memory location #1
    int b : 5;  // memory location #2
    int c : 11, // memory location #2 (continued)
    char  : 0,
    int d : 8;  // memory location #3
    struct {
        int ee : 8; // memory location #4
    } e;
} obj; // The object 'obj' consists of 4 separate memory locations



类的静态成员不占用类的空间，静态成员在程序数据段中。

对齐
Cf. https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/#comment-563585
Cf. http://www.catb.org/esr/structure-packing/
模板
重载与特化
从编译到函数模板的调用，编译器必须在非模板重载、模板重载和模板重载的特化间决定。


1
2
3
4
5
6
7
8
9


template< class T > void f(T);              // #1 ：模板重载
template< class T > void f(T*);             // #2 ：模板重载
void                     f(double);         // #3 ：非模板重载
template<>          void f(int);            // #4 ： #1 的特化

f('a');        // 调用 #1
f(new int(1)); // 调用 #2
f(1.0);        // 调用 #3
f(1);          // 调用 #4


注意只有非模板和初等模板重载参与重载决议。特化不是重载，且不受考虑。只有在重载决议选择最佳匹配初等函数模板后，才检验其特化以查看何为最佳匹配。


1
2
3
4
5


template< class T > void f(T);    // #1 ：所有类型的重载
template<>          void f(int*); // #2 ：为指向 int 的指针特化 #1
template< class T > void f(T*);   // #3 ：所有指针类型的重载

f(new int(1)); // 调用 #3 ，即使通过 #1 的特化会是完美匹配


即重载的优先级要高于特化。
关于模板函数重载的更多内容，参考function_template。
预编译
Cf. https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/
#include
When you #include a file, the preprocessor replaces the #include directive with the contents of the included file. The included contents are then preprocessed (along with the rest of the file), and then compiled.
Macro defines
The #define directive can be used to create a macro. In C++, a macro is a rule that defines how input text is converted into replacement output text.
There are two basic types of macros: object-like macros, and function-like macros.
Object-like macros can be defined in one of two ways:


1
2


#define identifier
#define identifier substitution_text


Object-like macros don’t affect other preprocessor directives
结论：宏展开在预编译指令(Preprocessor directives)无效。


1
2
3


#define PRINT_JOE
#ifdef PRINT_JOE    // 此处会否将'PRINT_JOE'替换为空呢？
// ...


Macros only cause text substitution for normal code. Other preprocessor commands are ignored. Consequently, the PRINT_JOE in #ifdef PRINT_JOE is left alone.
For example:


1
2
3
4
5


#define FOO 9 // Here's a macro substitution

#ifdef FOO // This FOO does not get replaced because it’s part of another preprocessor directive
    std::cout << FOO; // This FOO gets replaced with 9 because it's part of the normal code
#endif


In actuality, the output of the preprocessor contains no directives at all &ndash; they are all resolved/stripped out before compilation, because the compiler wouldn’t know what to do with them.
The scope of defines
Once the preprocessor has finished, all defined identifiers from that file are discarded. This means that directives are only valid from the point of definition to the end of the file in which they are defined. Directives defined in one code file do not have impact on other code files in the same project.
宏定义仅在本文件有效，一旦预编译阶段结束，所有宏都将失效。因为，预编译就是将所有的预编译指令都处理掉，该替换的替换（宏展开），该选择的选择，该丢弃的丢弃（条件编译），然后交给编译器去编译，谨记：编译器是读不懂预编译指令的！
Consider the following example:
function.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


#include <iostream>

void doSomething()
{
#ifdef PRINT
    std::cout << &#34;Printing!&#34;;
#endif
#ifndef PRINT
    std::cout << &#34;Not printing!&#34;;
#endif
}


main.cpp:


1
2
3
4
5
6
7
8
9


void doSomething(); // forward declaration for function doSomething()

#define PRINT

int main()
{
    doSomething();
    return 0;
}


The above program will print:
Not printing!
Even though PRINT was defined in main.cpp, that doesn’t have any impact on any of the code in function.cpp (PRINT is only #defined from the point of definition to the end of main.cpp). This will be of consequence when we discuss header guards in a future lesson.
Header files
Cf. https://www.learncpp.com/cpp-tutorial/header-files/
对于多文件项目，文件是单独编译的。要想调用一个自定义函数，linker必须能找到这个函数在哪里定义。


1
2
3
4
5
6
7


int add(int, int);  // forward declaration

int main()
{
    // add(3, 5);
    return 0;
}


上述文件是可以编译通过的，因为没有发生对add的调用，所以linker不会去找add的定义（当然如果要找也找不到）。
但是如果某处发起了对add的调用（例如去掉注释），那么上述程序在link阶段会报错：


1
2
3
4


yychi@~> clang test_linker.cpp
/usr/bin/ld: /tmp/test_linker-e1bb8b.o: in function `main':
test_linker.cpp:(.text+0x1a): undefined reference to `add(int, int)'
clang-13: error: linker command failed with exit code 1 (use -v to see invocation)


在多文件编程时，往往需要forawrd declaration，这些前置声明必须在其他某个地方被定义且只被定义一次。这样，linker才能正确的完成链接。任何重复定义或未定义都会在link阶段报错。
考虑如下例子：
add.cpp:


1
2
3
4


int add(int x, int y)
{
    return x + y;
}


main.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


#include <stdio.h>

int add(int, int);

int main()
{
    int x = 1, y = 2;
    int z = add(x, y);
    printf(&#34;z=%d\n&#34;, z);
    return 0;
}


在编译main.cpp的时候，因为有add的前置声明，所以可以通过。但为了link的时候能够找到add的定义，add.cpp必须也被编译，所以正确的编译方式应该是：


1


$ clang main.cpp add.cpp


Use of header files
从上面的论述我们隐约可见，在多文件编程中，我们可能会大量的使用前置声明（forward declaration），一旦文件多起来，这将非常枯燥。所以头文件的出现就是为了解决这个问题：把所有的声明放在一起。
Let’s write a header file to relieve us of this burden. Writing a header file is surprisingly easy, as header files only consist of two parts:

A header guard.
The actual content of the header file, which should be the forward declarations for all of the identifiers we want other files to be able to see.

add.h:


1
2
3
4


// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)

// 2) This is the content of the .h file, which is where the declarations go
int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!


main.cpp:


1
2
3
4
5
6
7
8


#include &#34;add.h&#34; // Insert contents of add.h at this point.  Note use of double quotes here.
#include <iostream>

int main()
{
    std::cout << &#34;The sum of 3 and 4 is &#34; << add(3, 4) << '\n';
    return 0;
}


add.cpp:


1
2
3
4
5
6


#include &#34;add.h&#34; // Insert contents of add.h at this point.  Note use of double quotes here.

int add(int x, int y)
{
    return x + y;
}


When the preprocessor processes the #include &#34;add.h&#34; line, it copies the contents of add.h into the current file at that point. Because our add.h contains a forward declaration for function add, that forward declaration will be copied into main.cpp. The end result is a program that is functionally the same as the one where we manually added the forward declaration at the top of main.cpp.
Consequently, our program will compile and link correctly.

Two wrong cases

如上图所示，会产生一个重复定义的错误。由于add.h中包含了函数定义，而非前置声明。编译main.cpp的时候，add.h中的代码插入到main.cpp中，产生一次add函数的定义。同理，编译add.cpp的时候也定义了一次add函数。link阶段会发生歧义，以致报错。
此时如果不编译add.cpp其实是可行的：

但谁又能保证只有一个文件#include &#34;add.h&#34;呢？所以头文件中应该只包含声明，而不应该包含实现。

The primary purpose of a header file is to propagate declarations to code files.

Key insight: Header files allow us to put declarations in one location and then import them wherever we need them. This can save a lot of typing in multi-file programs.
Header files should generally not contain function and variable definitions, so as not to violate the one definition rule. An exception is made for symbolic constants (which we cover in lesson 4.15 &ndash; Symbolic constants: const and constexpr variables).
标准库自动链接

注意：clang不会自动链接，需要手动链接
clang main.cpp -lstdc++

When it comes to functions and variables, it’s worth keeping in mind that header files typically only contain function and variable declarations, not function and variable definitions (otherwise a violation of the one definition rule could result). std::cout is forward declared in the iostream header, but defined as part of the C++ standard library, which is automatically linked into your program during the linker phase.

The #include order of header files
Cf. https://www.learncpp.com/cpp-tutorial/header-files/  for &ldquo;the #inclue order of header files&rdquo;.
A view of memory and fundamental data types in cpp
Cf. https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/
The smallest unit of memory is a binary digit (also called a bit), which can hold a value of 0 or 1. You can think of a bit as being like a traditional light switch &ndash; either the light is off (0), or it is on (1). There is no in-between. If you were to look at a random segment of memory, all you would see is …011010100101010… or some combination thereof.
Memory is organized into sequential units called memory addresses (or addresses for short). Similar to how a street address can be used to find a given house on a street, the memory address allows us to find and access the contents of memory at a particular location.
Perhaps surprisingly, in modern computer architectures, each bit does not get its own unique memory address. This is because the number of memory addresses are limited, and the need to access data bit-by-bit is rare. Instead, each memory address holds 1 byte of data. A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.
Data types
Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way. You have already seen one example of a data type: the integer. When we declare a variable as an integer, we are telling the compiler “the piece of memory that this variable uses is going to be interpreted as an integer value”.
When you give an object a value, the compiler and CPU take care of encoding your value into the appropriate sequence of bits for that data type, which are then stored in memory (remember: memory can only store bits). For example, if you assign an integer object the value 65, that value is converted to the sequence of bits 0100 0001 and stored in the memory assigned to the object.
Conversely, when the object is evaluated to produce a value, that sequence of bits is reconstituted back into the original value. Meaning that 0100 0001 is converted back into the value 65.
Fortunately, the compiler and CPU do all the hard work here, so you generally don’t need to worry about how values get converted into bit sequences and back.
All you need to do is pick a data type for your object that best matches your desired use.
谨记：内存只能存bit，只能寻址寻到byte这一层，如果数据按内存边界对齐，寻址会更快（一次读）。
由于内存地址空间有限，且按bit寻址的场景很少，所以寻址单位一般是byte。A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.
移位


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40


#include <cstdint>
#include <iostream>
using namespace std;

static void print(int32_t a, uint32_t b, size_t n_shift)
{
    cout << &#34;a=&#34; << a << &#34;; b=&#34; << b << endl;

    cout << &#34;left shift &#34; << n_shift << &#34; bit(s) of a is: &#34; << (a << n_shift) << endl;
    cout << &#34;left shift &#34; << n_shift << &#34; bit(s) of b is: &#34; << (b << n_shift) << endl;
    cout << &#34;right shift &#34; << n_shift << &#34; bit(s) of a is: &#34; << (a >> n_shift) << endl;
    cout << &#34;right shift &#34; << n_shift << &#34; bit(s) of b is: &#34; << (b >> n_shift) << endl;
}

int main()
{
    int32_t a = 0xffffffff;
    uint32_t b = 0xffffffff;
    print(a, b, 1);
    cout << &#34;------------\n&#34;;
    print(0xbfffffff, b, 1);
    return 0;
}

/**
 * Output on my machine:

a=-1; b=4294967295
left shift 1 bit(s) of a is: -2
left shift 1 bit(s) of b is: 4294967294
right shift 1 bit(s) of a is: -1
right shift 1 bit(s) of b is: 2147483647
------------
a=-1073741825; b=4294967295
left shift 1 bit(s) of a is: 2147483646
left shift 1 bit(s) of b is: 4294967294
right shift 1 bit(s) of a is: -536870913
right shift 1 bit(s) of b is: 2147483647

 */


从内存连续bit来看，a和b都是存了4 byte的1，区别仅仅是data type不一样，导致了截然不同的结果。
移位操作

右移

无符号右移，低位丢失高位补0
有符号右移，低位丢失，高位补符号位（正为0, 负为1）


左移：高位丢失，低位补0

a和b左移一位都得到：
0xfffffffe: 如果是int解释为-2, unsigned int解释为4294967294=2^32 - 2
a右移一位得到
0xffffffff: 注意负数右移，高位补1，int解释为-1
b右移一位得到
0x7fffffff: 高位补0, unsigned int解释为2147483647=2^31-1
注意，负的可能左移成正的，因此，有符号的移位是不安全的。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


#include <iostream>

int main()
{
    signed int s { -1 };
    unsigned int u { 1 };

    if (s < u) // -1 is implicitly converted to 4294967295, and 4294967295 < 1 is false
        std::cout << &#34;-1 is less than 1\n&#34;;
    else
        std::cout << &#34;1 is less than -1\n&#34;; // this statement executes

    return 0;
}


NOTE:

注意无符号数相减得负数会导致溢出
usigned和--运算符，可能减至负数溢出
除非确定变量值非负，否则尽量避免使用unsigned
切忌不要在数学计算中混用unsigned和signed，此时signed会隐式转换为unsigned
unsigned numbers are preferred when dealing with bit manipulation
std::int8_t和std::uint8_t可能知识char和unsigned char的别名，可能有坑（参考：https://www.learncpp.com/cpp-tutorial/introduction-to-type-conversion-and-static_cast/）

Best practice
Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.
字节序


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38


/**
 * This file test the endian of your machine:
 * big-endian or little-endian, by visiting
 * the memory sequentially byte by byte of
 * a intendly constructed integer.
 */

#include <cstdint>
#include <stdio.h>
#include <iostream>

using namespace std;

static void print(void* ptr, size_t size)
{
    // convert to char* so we can visit the memory byte by byte
    unsigned char* _ptr = static_cast<unsigned char*>(ptr);
    // print the value of each byte in ptr
    for (size_t i = 0; i < size; ++i)
        cout << static_cast<int>(_ptr[i]);
    cout << endl;
}

int main()
{
    uint32_t a = 0x01020304;
    /*
     * if it prints 4321, indicates 低位在前，对应little-endian
     * it it prints 1234, indicates 高位在前，对应big-endian
     */
    print(&amp;a, 4);
    return 0;
}

/**
 * Output on my machine
4321
 */


字节序就是计算机存储数据的时候将低位数据存在低位地址还是高位地址。举个例子，数值0x2211使用两个字节储存：高位字节是0x22，低位字节是0x11。

大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。
小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。

如果太多记不住，至少要记住：

字节序的概念: 读一段内存从低位向高位读（从左往右），先读到高位字节还是低位字节
符合人类读写数值的方法是大端序（big-endian）

既然如此，我们要判断一台机器是big-endian还是little-endian，只需要构造一端内存，按字节从低位地址向高位地址访问，看看低位地址存的是高位字节，还是低位字节即可。
且看上述代码，构造了一个整数0x01020304，然后通过将首地址转成char*的方式去按字节读取内存中的值（这样做的目的是，char*可以逐字节的读取内存；而int*一次指针移动会移动sizeof(int)个字节）。读出来如果是符合书写习惯的1234, 则表明机器是big-endian, 反之little-endian.
这也是一段内存的两种不同的解释方式，recall that Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way.
链接（Linkage）
Cf. https://www.learncpp.com/cpp-tutorial/internal-linkage/
Identifiers have another property named linkage. An identifier’s linkage determines whether other declarations of that name refer to the same object or not.
Local variables have no linkage, which means that each declaration refers to a unique object.
Global variable and functions identifiers can have either internal linkage or external linkage.
An identifier with internal linkage can be seen and used within a single file, but it is not accessible from other files (that is, it is not exposed to the linker). This means that if two files have identically named identifiers with internal linkage, those identifiers will be treated as independent.
To make a non-constant global variable internal, we use the static keyword.


1
2
3
4
5
6
7
8
9


static int g_x; // non-constant globals have external linkage by default, but can be given internal linkage via the static keyword

const int g_y { 1 }; // const globals have internal linkage by default
constexpr int g_z { 2 }; // constexpr globals have internal linkage by default

int main()
{
    return 0;
}


To see it, we take
a.cpp:


1
2
3


int g_x = 22;
const int g_y = 33;
constexpr int g_z = 44;


main.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


#include <stdio.h>

int g_x = 222;
const int g_y = 333;
constexpr int g_z = 444;

int main()
{
    printf(&#34;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&#34;, g_x, g_y, g_z);
    return 0;
}


if we compile only main.cpp, it works fine and outputs:
glabal variable (g_x, g_y, g_z) is (222, 333, 444)
But if we compile both, it gets


1
2
3


$ clang main.cpp a.cpp
/usr/bin/ld: /tmp/a-ea4f54.o:(.data+0x0): multiple definition of `g_x'; /tmp/main-c44eb4.o:(.data+0x0): first defined here
clang-13: error: linker command failed with exit code 1 (use -v to see invocation)


As we sligtly modify main.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


#include <stdio.h>

extern int g_x;
const int g_y = 333;
constexpr int g_z = 444;

int main()
{
    printf(&#34;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&#34;, g_x, g_y, g_z);
    return 0;
}


it&rsquo;s compiled and linked properly with the output:
glabal variable (g_x, g_y, g_z) is (22, 333, 444)
noting that the g_x has the value 22 which is defined in a.cpp, we find out the global non-const variable has external linkage. And the properly compilation and linking show that global const has internal linkage.
External linkage
Cf. https://www.learncpp.com/cpp-tutorial/external-linkage/
An identifier with external linkage can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration). In this sense, identifiers with external linkage are truly “global” in that they can be used anywhere in your program!
Functions have external linkage by default
In order to call a function defined in another file, you must place a forward declaration for the function in any other files wishing to use the function. The forward declaration tells the compiler about the existence of the function, and the linker connects the function calls to the actual function definition.
Global variables with external linkage
Global variables with external linkage are sometimes called external variables. To make a global variable external (and thus accessible by other files), we can use the extern keyword to do so:


1
2
3
4
5
6
7
8
9


int g_x { 2 }; // non-constant globals are external by default

extern const int g_y { 3 }; // const globals can be defined as extern, making them external
extern constexpr int g_z { 3 }; // constexpr globals can be defined as extern, making them external (but this is useless, see the note in the next section)

int main()
{
    return 0;
}


Non-const global variables are external by default (if used, the extern keyword will be ignored).
To actually use an external global variable that has been defined in another file, you also must place a forward declaration for the global variable in any other files wishing to use the variable. For variables, creating a forward declaration is also done via the extern keyword (with no initialization value).
Here is an example of using a variable forward declaration:
a.cpp:


1
2
3


// global variable definitions
int g_x { 2 }; // non-constant globals have external linkage by default
extern const int g_y { 3 }; // this extern gives g_y external linkage


main.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


#include <iostream>

extern int g_x; // this extern is a forward declaration of a variable named g_x that is defined somewhere else
extern const int g_y; // this extern is a forward declaration of a const variable named g_y that is defined somewhere else

int main()
{
    std::cout << g_x; // prints 2
    return 0;
}


Note that the extern keyword has different meanings in different contexts. In some contexts, extern means “give this variable external linkage”. In other contexts, extern means “this is a forward declaration for an external variable that is defined somewhere else”.
Summary
Scope determines where a variable is accessible. Duration determines where a variable is created and destroyed. Linkage determines whether the variable can be exported to another file or not.
Inline function
考虑如下场景，有一段代码很独立，适合抽成一个函数，但你又担心函数调用开销，此时inline function就是你的最佳选择。关于合适使用inline function，下面这段话给了一定的意见：

For functions that are large and/or perform complex tasks, the overhead of the function call is typically insignificant compared to the amount of time the function takes to run. However, for small functions, the overhead costs can be larger than the time needed to actually execute the function’s code! In cases where a small function is called often, using a function can result in a significant performance penalty over writing the same code in-place.

Inline function的好处包括：

没有函数调用的开销
编译器对展开后的代码有更大的优化空间（如常量替换）

However, inline expansion has its own potential cost: if the body of the function being expanded takes more instructions than the function call being replaced, then each inline expansion will cause the executable to grow larger. Larger executables tend to be slower (due to not fitting as well in caches).

注意：inline只是对编译器的一个建议，是否会真的展开取决于编译器的优化策略。

However, in modern C++, the inline keyword is no longer used to request that a function be expanded inline. There are quite a few reasons for this:

Using inline to request inline expansion is a form of premature optimization, and misuse could actually harm performance.
The inline keyword is just a hint &ndash; the compiler is completely free to ignore a request to inline a function. This is likely to be the result if you try to inline a lengthy function! The compiler is also free to perform inline expansion of functions that do not use the inline keyword  as part of its normal set of optimizations.
The inline keyword is defined at the wrong level of granularity. We use the inline keyword on a function declaration, but inline expansion is actually determined per function call. It may be beneficial to expand some function calls and detrimental to expand others, and there is no syntax to affect this.

注意：在modern cpp中，用inline修饰的不违反ODR（one definition rule），因此可用于

头文件中修饰常量作为global const的最佳方案1
头文件中修饰constexpr函数2使所有include该文件的源文件都能使用该函数，注意constexpr函数是默认inline的


Allowing functions with a constexpr return type to be evaluated at either compile-time or runtime was allowed so that a single function can serve both cases. Otherwise, you’d need to have separate functions (a constexpr version and a non-constexpr version) &ndash; and since return type isn’t considered in function overload resolution, you’d have to name the functions different things!
A constexpr function that is eligible to be evaluated at compile-time will only be evaluated at compile-time if the return value is used where a constant expression is required. Otherwise, compile-time evaluation is not guaranteed.
Thus, a constexpr function is better thought of as “can be used in a constant expression”, not “will be evaluated at compile-time”.

Unnamed namespace
An unnamed namespace (also called an anonymous namespace) is a namespace that is defined without a name, like so:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16


#include <iostream>

namespace // unnamed namespace
{
    void doSomething() // can only be accessed in this file
    {
        std::cout << &#34;v1\n&#34;;
    }
}

int main()
{
    doSomething(); // we can call doSomething() without a namespace prefix

    return 0;
}


特点：

All content declared in an unnamed namespace is treated as if it is part of the parent namespace.
All identifiers inside an unnamed namespace are treated as if they had internal linkage.

解决的问题：Unnamed namespaces will also keep user-defined types (something we’ll discuss in a later lesson) local to the file, something for which there is no alternative equivalent mechanism to do.
About switch clause
Put another way, defining a variable without an initializer is just telling the compiler that the variable is now in scope from that point on. This happens at compile time, and doesn’t require the definition to actually be executed at runtime.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19


int calculate(int x, int y, char op)
{
    int ret = 0;
    switch (op)
    {
    case '+':
        return x + y;
        case '-':
        return x - y;
        case '*':
        return x * y;
        case '/':
        return x / y;
        case '%':
        return x % y;
        default:
        throw std::invalid_arguments(&#34;invalid operator&#34;);
    }
}


Pointer to functions
The syntax for creating a non-const function pointer is one of the ugliest things you will ever see in C++:
// fcnPtr is a pointer to a function that takes no arguments and returns an integer
int (*fcnPtr)();
In the above snippet, fcnPtr is a pointer to a function that has no parameters and returns an integer. fcnPtr can point to any function that matches this type.
To make a const function pointer, the const goes after the asterisk:
int (*const fcnPtr)();
If you put the const before the int, then that would indicate the function being pointed to would return a const int."><meta itemprop=datePublished content="2019-08-28T00:00:00+00:00"><meta itemprop=dateModified content="2023-05-28T21:47:34+08:00"><meta itemprop=wordCount content="9337"><meta itemprop=keywords content="cpp,note,"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ 学习笔记"><meta name=twitter:description content="诚如是，Life is too short to learn c++. 此篇记录一些我在学习cpp过程中遇到的一些知识点，仅作记录并梳理之效。里面可能会有大量参考其他网络博客，如有侵权，请联系我删除之。
Reactor v.s. Proactor

epll/wait: reactor模式，不停轮询，发现有事做，就做！
asio: proactor模式，先注册好事件，如果事情发生了，通过回调函数处理。

几个常用的宏

__func__: name of an function, exists in C99/C++11 (__FUNCTION__ is non standard)
__LINE__: line number of the code
__FILE__: filename of the file
__DATE__ and __TIME__: as you wish

不要在ctor里调用虚函数
总结来说：基类部分在派生类部分之前被构造，当基类构造函数执行时派生类中的数据成员还没被初始化。如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug。
ctor应该设计的尽量简单，确保对象可以被正确构造。在ctor中调用本类的非静态成员都是不安全的，因为他们还没被构造，而有些成员是依赖对象的，而此时对象还没有被成功构造。
ctor不能是虚函数


从存储空间角度：虚函数对应一个vtable（虚函数表），这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。


从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。
虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。


构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。


——————————————————
版权声明：本文为CSDN博主「cainiao000001」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/cainiao000001/article/details/81603782
虚函数的工作原理
https://zhuanlan.zhihu.com/p/60543586
C++ 规定了虚函数的行为，但将实现方法留给了编译器的作者。不需要知道实现方法也可以很好的使用虚函数，但了解虚函数的工作原理有助于更好地理解概念。
通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。
这种数组称为虚函数表（Virtual Function Table, vtbl）。
虚函数表是一个数组，数组的元素是指针，指针指的是虚函数的地址。
具有虚函数的类的实例，都会在头部存一个指向虚函数表的指针。
常见类型所占空间大小



TYPE
Bytes




(unsigned) int
4


(unsigned) short
2


(unsigned) long
8


float
4


double
8


long double
16


(unsigned) char
1


bool
1



指针占几个字节 指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关，譬如以前是16为地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就为8个字节。

NOTE: 类成员函数指针一般为普通指针的两倍大小。

literal 5.0类型为double，5.0f类型为float。不加f后缀默认double.
静态成员的初始化
当一个类包含静态成员时，最好的做法是在类中声明，在类外初始化。由于静态成员是所有对象共享的，如果在类内初始化，则每个对象构造时，都要执行一遍静态成员的初始化，这无疑是一种浪费。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


struct A
{
  static int a;
  int b;
  void fun();
  ...
};

int A::a = 233;

class B
{
public:
  void fun();
  ...
private:
  static string str_;
  bool done_;
};

string B::str_ = &#34;hello, i am static&#34;;


析构函数的调用时机
The destructor is called whenever an object&rsquo;s lifetime ends, which includes

program termination, for objects with static storage duration
thread exit, for objects with thread-local storage duration
end of scope, for objects with automatic storage duration and for temporaries whose life was extended by binding to reference
delete-expressin, for objects with dynamic storage duration
end of the full expression, for nameless temporaries
stack unwinding (栈回溯), for objects with automatic storage duration when an exception escapes their block, uncaught.

cf. https://en.cppreference.com/w/cpp/language/destructor
常量
Literal constants
字面值常量
Cf. https://www.learncpp.com/cpp-tutorial/literals/
Symbolic constants
符号常量
Cf. https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/

Const variables must be initialized
Function parameters for arguments passed by value should not be made const.
Don’t use const with return by value.

Runtime vs compile-time constants
Runtime constants are constants whose initialization values can only be resolved at runtime (when your program is running). The following are examples of runtime constants:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20


#include <iostream>

void printInt(const int x) // x is a runtime constant because the value isn't known until the program is run
{
    std::cout << x;
}

int main()
{
    std::cout << &#34;Enter your age: &#34;;
    int age{};
    std::cin >> age;

    const int usersAge { age }; // usersAge is a runtime constant because the value isn't known until the program is run

    std::cout << &#34;Your age is: &#34;;
    printInt(age);

    return 0;
}


Compile-time constants are constants whose initialization values can be determined at compile-time (when your program is compiling). The following are examples of compile-time constants:


1
2


const double gravity { 9.8 }; // the compiler knows at compile-time that gravity will have value 9.8
const int something { 1 + 2 }; // the compiler can resolve this at compiler time


Compile-time constants enable the compiler to perform optimizations that aren’t available with runtime constants. For example, whenever gravity is used, the compiler can simply substitute the identifier gravity with the literal double 9.8.
To help provide more specificity, C++11 introduced the keyword constexpr, which ensures that a constant must be a compile-time constant.

Any variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as constexpr.
Any variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as const.

Note that literals are also implicitly constexpr, as the value of a literal is known at compile-time.
A constant expression is an expression that can be evaluated at compile-time. For example:


1
2
3
4
5
6


#include <iostream>
int main()
{
	std::cout << 3 + 4; // 3 + 4 evaluated at compile-time
	return 0;
}


In the above program, because the literal values 3 and 4 are known at compile-time, the compiler can evaluate the expression 3 + 4 at compile-time and substitute in the resulting value 7. That makes the code faster because 3 + 4 no longer has to be calculated at runtime.
Constexpr variables can also be used in constant expressions:


1
2
3
4
5
6
7
8


#include <iostream>
int main()
{
	constexpr int x { 3 };
	constexpr int y { 4 };
	std::cout << x + y; // x + y evaluated at compile-time
	return 0;
}


In the above example, because x and y are constexpr, the expression x + y is a constant expression that can be evaluated at compile-time. Similar to the literal case, the compiler can substitute in the value 7.
Object-like preprocessor macros v.s. symbolic constants
Object-like macro has the form:


1


#define identifier substitution_text


Whenever the preprocessor encounters this directive, any further occurrence of identifier is replaced by substitution_text. The identifier is traditionally typed in all capital letters, using underscores to represent spaces.

Avoid using #define to create symbolic constants macros. Use const or constexpr variables instead.

Macros can have naming conflicts with normal code. For example:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


#include &#34;someheader.h&#34;
#include <iostream>

int main()
{
    int beta { 5 };
    std::cout << beta;

    return 0;
}


If someheader.h happened to #define a macro named beta, this simple program would break, as the preprocessor would replace the int variable beta’s name with whatever the macro’s value was. This is normally avoided by using all caps for macro names, but it can still happen.
Using symbolic constants throughout a multi-file program
Cf. https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/
内存布局
结构体
C++规范在“结构”上使用了和C相同的，简单的内存布局原则：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


struct S {
    char a;     // memory location #1
    int b : 5;  // memory location #2
    int c : 11, // memory location #2 (continued)
    char  : 0,
    int d : 8;  // memory location #3
    struct {
        int ee : 8; // memory location #4
    } e;
} obj; // The object 'obj' consists of 4 separate memory locations



类的静态成员不占用类的空间，静态成员在程序数据段中。

对齐
Cf. https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/#comment-563585
Cf. http://www.catb.org/esr/structure-packing/
模板
重载与特化
从编译到函数模板的调用，编译器必须在非模板重载、模板重载和模板重载的特化间决定。


1
2
3
4
5
6
7
8
9


template< class T > void f(T);              // #1 ：模板重载
template< class T > void f(T*);             // #2 ：模板重载
void                     f(double);         // #3 ：非模板重载
template<>          void f(int);            // #4 ： #1 的特化

f('a');        // 调用 #1
f(new int(1)); // 调用 #2
f(1.0);        // 调用 #3
f(1);          // 调用 #4


注意只有非模板和初等模板重载参与重载决议。特化不是重载，且不受考虑。只有在重载决议选择最佳匹配初等函数模板后，才检验其特化以查看何为最佳匹配。


1
2
3
4
5


template< class T > void f(T);    // #1 ：所有类型的重载
template<>          void f(int*); // #2 ：为指向 int 的指针特化 #1
template< class T > void f(T*);   // #3 ：所有指针类型的重载

f(new int(1)); // 调用 #3 ，即使通过 #1 的特化会是完美匹配


即重载的优先级要高于特化。
关于模板函数重载的更多内容，参考function_template。
预编译
Cf. https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/
#include
When you #include a file, the preprocessor replaces the #include directive with the contents of the included file. The included contents are then preprocessed (along with the rest of the file), and then compiled.
Macro defines
The #define directive can be used to create a macro. In C++, a macro is a rule that defines how input text is converted into replacement output text.
There are two basic types of macros: object-like macros, and function-like macros.
Object-like macros can be defined in one of two ways:


1
2


#define identifier
#define identifier substitution_text


Object-like macros don’t affect other preprocessor directives
结论：宏展开在预编译指令(Preprocessor directives)无效。


1
2
3


#define PRINT_JOE
#ifdef PRINT_JOE    // 此处会否将'PRINT_JOE'替换为空呢？
// ...


Macros only cause text substitution for normal code. Other preprocessor commands are ignored. Consequently, the PRINT_JOE in #ifdef PRINT_JOE is left alone.
For example:


1
2
3
4
5


#define FOO 9 // Here's a macro substitution

#ifdef FOO // This FOO does not get replaced because it’s part of another preprocessor directive
    std::cout << FOO; // This FOO gets replaced with 9 because it's part of the normal code
#endif


In actuality, the output of the preprocessor contains no directives at all &ndash; they are all resolved/stripped out before compilation, because the compiler wouldn’t know what to do with them.
The scope of defines
Once the preprocessor has finished, all defined identifiers from that file are discarded. This means that directives are only valid from the point of definition to the end of the file in which they are defined. Directives defined in one code file do not have impact on other code files in the same project.
宏定义仅在本文件有效，一旦预编译阶段结束，所有宏都将失效。因为，预编译就是将所有的预编译指令都处理掉，该替换的替换（宏展开），该选择的选择，该丢弃的丢弃（条件编译），然后交给编译器去编译，谨记：编译器是读不懂预编译指令的！
Consider the following example:
function.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


#include <iostream>

void doSomething()
{
#ifdef PRINT
    std::cout << &#34;Printing!&#34;;
#endif
#ifndef PRINT
    std::cout << &#34;Not printing!&#34;;
#endif
}


main.cpp:


1
2
3
4
5
6
7
8
9


void doSomething(); // forward declaration for function doSomething()

#define PRINT

int main()
{
    doSomething();
    return 0;
}


The above program will print:
Not printing!
Even though PRINT was defined in main.cpp, that doesn’t have any impact on any of the code in function.cpp (PRINT is only #defined from the point of definition to the end of main.cpp). This will be of consequence when we discuss header guards in a future lesson.
Header files
Cf. https://www.learncpp.com/cpp-tutorial/header-files/
对于多文件项目，文件是单独编译的。要想调用一个自定义函数，linker必须能找到这个函数在哪里定义。


1
2
3
4
5
6
7


int add(int, int);  // forward declaration

int main()
{
    // add(3, 5);
    return 0;
}


上述文件是可以编译通过的，因为没有发生对add的调用，所以linker不会去找add的定义（当然如果要找也找不到）。
但是如果某处发起了对add的调用（例如去掉注释），那么上述程序在link阶段会报错：


1
2
3
4


yychi@~> clang test_linker.cpp
/usr/bin/ld: /tmp/test_linker-e1bb8b.o: in function `main':
test_linker.cpp:(.text+0x1a): undefined reference to `add(int, int)'
clang-13: error: linker command failed with exit code 1 (use -v to see invocation)


在多文件编程时，往往需要forawrd declaration，这些前置声明必须在其他某个地方被定义且只被定义一次。这样，linker才能正确的完成链接。任何重复定义或未定义都会在link阶段报错。
考虑如下例子：
add.cpp:


1
2
3
4


int add(int x, int y)
{
    return x + y;
}


main.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


#include <stdio.h>

int add(int, int);

int main()
{
    int x = 1, y = 2;
    int z = add(x, y);
    printf(&#34;z=%d\n&#34;, z);
    return 0;
}


在编译main.cpp的时候，因为有add的前置声明，所以可以通过。但为了link的时候能够找到add的定义，add.cpp必须也被编译，所以正确的编译方式应该是：


1


$ clang main.cpp add.cpp


Use of header files
从上面的论述我们隐约可见，在多文件编程中，我们可能会大量的使用前置声明（forward declaration），一旦文件多起来，这将非常枯燥。所以头文件的出现就是为了解决这个问题：把所有的声明放在一起。
Let’s write a header file to relieve us of this burden. Writing a header file is surprisingly easy, as header files only consist of two parts:

A header guard.
The actual content of the header file, which should be the forward declarations for all of the identifiers we want other files to be able to see.

add.h:


1
2
3
4


// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)

// 2) This is the content of the .h file, which is where the declarations go
int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!


main.cpp:


1
2
3
4
5
6
7
8


#include &#34;add.h&#34; // Insert contents of add.h at this point.  Note use of double quotes here.
#include <iostream>

int main()
{
    std::cout << &#34;The sum of 3 and 4 is &#34; << add(3, 4) << '\n';
    return 0;
}


add.cpp:


1
2
3
4
5
6


#include &#34;add.h&#34; // Insert contents of add.h at this point.  Note use of double quotes here.

int add(int x, int y)
{
    return x + y;
}


When the preprocessor processes the #include &#34;add.h&#34; line, it copies the contents of add.h into the current file at that point. Because our add.h contains a forward declaration for function add, that forward declaration will be copied into main.cpp. The end result is a program that is functionally the same as the one where we manually added the forward declaration at the top of main.cpp.
Consequently, our program will compile and link correctly.

Two wrong cases

如上图所示，会产生一个重复定义的错误。由于add.h中包含了函数定义，而非前置声明。编译main.cpp的时候，add.h中的代码插入到main.cpp中，产生一次add函数的定义。同理，编译add.cpp的时候也定义了一次add函数。link阶段会发生歧义，以致报错。
此时如果不编译add.cpp其实是可行的：

但谁又能保证只有一个文件#include &#34;add.h&#34;呢？所以头文件中应该只包含声明，而不应该包含实现。

The primary purpose of a header file is to propagate declarations to code files.

Key insight: Header files allow us to put declarations in one location and then import them wherever we need them. This can save a lot of typing in multi-file programs.
Header files should generally not contain function and variable definitions, so as not to violate the one definition rule. An exception is made for symbolic constants (which we cover in lesson 4.15 &ndash; Symbolic constants: const and constexpr variables).
标准库自动链接

注意：clang不会自动链接，需要手动链接
clang main.cpp -lstdc++

When it comes to functions and variables, it’s worth keeping in mind that header files typically only contain function and variable declarations, not function and variable definitions (otherwise a violation of the one definition rule could result). std::cout is forward declared in the iostream header, but defined as part of the C++ standard library, which is automatically linked into your program during the linker phase.

The #include order of header files
Cf. https://www.learncpp.com/cpp-tutorial/header-files/  for &ldquo;the #inclue order of header files&rdquo;.
A view of memory and fundamental data types in cpp
Cf. https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/
The smallest unit of memory is a binary digit (also called a bit), which can hold a value of 0 or 1. You can think of a bit as being like a traditional light switch &ndash; either the light is off (0), or it is on (1). There is no in-between. If you were to look at a random segment of memory, all you would see is …011010100101010… or some combination thereof.
Memory is organized into sequential units called memory addresses (or addresses for short). Similar to how a street address can be used to find a given house on a street, the memory address allows us to find and access the contents of memory at a particular location.
Perhaps surprisingly, in modern computer architectures, each bit does not get its own unique memory address. This is because the number of memory addresses are limited, and the need to access data bit-by-bit is rare. Instead, each memory address holds 1 byte of data. A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.
Data types
Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way. You have already seen one example of a data type: the integer. When we declare a variable as an integer, we are telling the compiler “the piece of memory that this variable uses is going to be interpreted as an integer value”.
When you give an object a value, the compiler and CPU take care of encoding your value into the appropriate sequence of bits for that data type, which are then stored in memory (remember: memory can only store bits). For example, if you assign an integer object the value 65, that value is converted to the sequence of bits 0100 0001 and stored in the memory assigned to the object.
Conversely, when the object is evaluated to produce a value, that sequence of bits is reconstituted back into the original value. Meaning that 0100 0001 is converted back into the value 65.
Fortunately, the compiler and CPU do all the hard work here, so you generally don’t need to worry about how values get converted into bit sequences and back.
All you need to do is pick a data type for your object that best matches your desired use.
谨记：内存只能存bit，只能寻址寻到byte这一层，如果数据按内存边界对齐，寻址会更快（一次读）。
由于内存地址空间有限，且按bit寻址的场景很少，所以寻址单位一般是byte。A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.
移位


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40


#include <cstdint>
#include <iostream>
using namespace std;

static void print(int32_t a, uint32_t b, size_t n_shift)
{
    cout << &#34;a=&#34; << a << &#34;; b=&#34; << b << endl;

    cout << &#34;left shift &#34; << n_shift << &#34; bit(s) of a is: &#34; << (a << n_shift) << endl;
    cout << &#34;left shift &#34; << n_shift << &#34; bit(s) of b is: &#34; << (b << n_shift) << endl;
    cout << &#34;right shift &#34; << n_shift << &#34; bit(s) of a is: &#34; << (a >> n_shift) << endl;
    cout << &#34;right shift &#34; << n_shift << &#34; bit(s) of b is: &#34; << (b >> n_shift) << endl;
}

int main()
{
    int32_t a = 0xffffffff;
    uint32_t b = 0xffffffff;
    print(a, b, 1);
    cout << &#34;------------\n&#34;;
    print(0xbfffffff, b, 1);
    return 0;
}

/**
 * Output on my machine:

a=-1; b=4294967295
left shift 1 bit(s) of a is: -2
left shift 1 bit(s) of b is: 4294967294
right shift 1 bit(s) of a is: -1
right shift 1 bit(s) of b is: 2147483647
------------
a=-1073741825; b=4294967295
left shift 1 bit(s) of a is: 2147483646
left shift 1 bit(s) of b is: 4294967294
right shift 1 bit(s) of a is: -536870913
right shift 1 bit(s) of b is: 2147483647

 */


从内存连续bit来看，a和b都是存了4 byte的1，区别仅仅是data type不一样，导致了截然不同的结果。
移位操作

右移

无符号右移，低位丢失高位补0
有符号右移，低位丢失，高位补符号位（正为0, 负为1）


左移：高位丢失，低位补0

a和b左移一位都得到：
0xfffffffe: 如果是int解释为-2, unsigned int解释为4294967294=2^32 - 2
a右移一位得到
0xffffffff: 注意负数右移，高位补1，int解释为-1
b右移一位得到
0x7fffffff: 高位补0, unsigned int解释为2147483647=2^31-1
注意，负的可能左移成正的，因此，有符号的移位是不安全的。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


#include <iostream>

int main()
{
    signed int s { -1 };
    unsigned int u { 1 };

    if (s < u) // -1 is implicitly converted to 4294967295, and 4294967295 < 1 is false
        std::cout << &#34;-1 is less than 1\n&#34;;
    else
        std::cout << &#34;1 is less than -1\n&#34;; // this statement executes

    return 0;
}


NOTE:

注意无符号数相减得负数会导致溢出
usigned和--运算符，可能减至负数溢出
除非确定变量值非负，否则尽量避免使用unsigned
切忌不要在数学计算中混用unsigned和signed，此时signed会隐式转换为unsigned
unsigned numbers are preferred when dealing with bit manipulation
std::int8_t和std::uint8_t可能知识char和unsigned char的别名，可能有坑（参考：https://www.learncpp.com/cpp-tutorial/introduction-to-type-conversion-and-static_cast/）

Best practice
Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.
字节序


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38


/**
 * This file test the endian of your machine:
 * big-endian or little-endian, by visiting
 * the memory sequentially byte by byte of
 * a intendly constructed integer.
 */

#include <cstdint>
#include <stdio.h>
#include <iostream>

using namespace std;

static void print(void* ptr, size_t size)
{
    // convert to char* so we can visit the memory byte by byte
    unsigned char* _ptr = static_cast<unsigned char*>(ptr);
    // print the value of each byte in ptr
    for (size_t i = 0; i < size; ++i)
        cout << static_cast<int>(_ptr[i]);
    cout << endl;
}

int main()
{
    uint32_t a = 0x01020304;
    /*
     * if it prints 4321, indicates 低位在前，对应little-endian
     * it it prints 1234, indicates 高位在前，对应big-endian
     */
    print(&amp;a, 4);
    return 0;
}

/**
 * Output on my machine
4321
 */


字节序就是计算机存储数据的时候将低位数据存在低位地址还是高位地址。举个例子，数值0x2211使用两个字节储存：高位字节是0x22，低位字节是0x11。

大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。
小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。

如果太多记不住，至少要记住：

字节序的概念: 读一段内存从低位向高位读（从左往右），先读到高位字节还是低位字节
符合人类读写数值的方法是大端序（big-endian）

既然如此，我们要判断一台机器是big-endian还是little-endian，只需要构造一端内存，按字节从低位地址向高位地址访问，看看低位地址存的是高位字节，还是低位字节即可。
且看上述代码，构造了一个整数0x01020304，然后通过将首地址转成char*的方式去按字节读取内存中的值（这样做的目的是，char*可以逐字节的读取内存；而int*一次指针移动会移动sizeof(int)个字节）。读出来如果是符合书写习惯的1234, 则表明机器是big-endian, 反之little-endian.
这也是一段内存的两种不同的解释方式，recall that Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way.
链接（Linkage）
Cf. https://www.learncpp.com/cpp-tutorial/internal-linkage/
Identifiers have another property named linkage. An identifier’s linkage determines whether other declarations of that name refer to the same object or not.
Local variables have no linkage, which means that each declaration refers to a unique object.
Global variable and functions identifiers can have either internal linkage or external linkage.
An identifier with internal linkage can be seen and used within a single file, but it is not accessible from other files (that is, it is not exposed to the linker). This means that if two files have identically named identifiers with internal linkage, those identifiers will be treated as independent.
To make a non-constant global variable internal, we use the static keyword.


1
2
3
4
5
6
7
8
9


static int g_x; // non-constant globals have external linkage by default, but can be given internal linkage via the static keyword

const int g_y { 1 }; // const globals have internal linkage by default
constexpr int g_z { 2 }; // constexpr globals have internal linkage by default

int main()
{
    return 0;
}


To see it, we take
a.cpp:


1
2
3


int g_x = 22;
const int g_y = 33;
constexpr int g_z = 44;


main.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


#include <stdio.h>

int g_x = 222;
const int g_y = 333;
constexpr int g_z = 444;

int main()
{
    printf(&#34;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&#34;, g_x, g_y, g_z);
    return 0;
}


if we compile only main.cpp, it works fine and outputs:
glabal variable (g_x, g_y, g_z) is (222, 333, 444)
But if we compile both, it gets


1
2
3


$ clang main.cpp a.cpp
/usr/bin/ld: /tmp/a-ea4f54.o:(.data+0x0): multiple definition of `g_x'; /tmp/main-c44eb4.o:(.data+0x0): first defined here
clang-13: error: linker command failed with exit code 1 (use -v to see invocation)


As we sligtly modify main.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


#include <stdio.h>

extern int g_x;
const int g_y = 333;
constexpr int g_z = 444;

int main()
{
    printf(&#34;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&#34;, g_x, g_y, g_z);
    return 0;
}


it&rsquo;s compiled and linked properly with the output:
glabal variable (g_x, g_y, g_z) is (22, 333, 444)
noting that the g_x has the value 22 which is defined in a.cpp, we find out the global non-const variable has external linkage. And the properly compilation and linking show that global const has internal linkage.
External linkage
Cf. https://www.learncpp.com/cpp-tutorial/external-linkage/
An identifier with external linkage can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration). In this sense, identifiers with external linkage are truly “global” in that they can be used anywhere in your program!
Functions have external linkage by default
In order to call a function defined in another file, you must place a forward declaration for the function in any other files wishing to use the function. The forward declaration tells the compiler about the existence of the function, and the linker connects the function calls to the actual function definition.
Global variables with external linkage
Global variables with external linkage are sometimes called external variables. To make a global variable external (and thus accessible by other files), we can use the extern keyword to do so:


1
2
3
4
5
6
7
8
9


int g_x { 2 }; // non-constant globals are external by default

extern const int g_y { 3 }; // const globals can be defined as extern, making them external
extern constexpr int g_z { 3 }; // constexpr globals can be defined as extern, making them external (but this is useless, see the note in the next section)

int main()
{
    return 0;
}


Non-const global variables are external by default (if used, the extern keyword will be ignored).
To actually use an external global variable that has been defined in another file, you also must place a forward declaration for the global variable in any other files wishing to use the variable. For variables, creating a forward declaration is also done via the extern keyword (with no initialization value).
Here is an example of using a variable forward declaration:
a.cpp:


1
2
3


// global variable definitions
int g_x { 2 }; // non-constant globals have external linkage by default
extern const int g_y { 3 }; // this extern gives g_y external linkage


main.cpp:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


#include <iostream>

extern int g_x; // this extern is a forward declaration of a variable named g_x that is defined somewhere else
extern const int g_y; // this extern is a forward declaration of a const variable named g_y that is defined somewhere else

int main()
{
    std::cout << g_x; // prints 2
    return 0;
}


Note that the extern keyword has different meanings in different contexts. In some contexts, extern means “give this variable external linkage”. In other contexts, extern means “this is a forward declaration for an external variable that is defined somewhere else”.
Summary
Scope determines where a variable is accessible. Duration determines where a variable is created and destroyed. Linkage determines whether the variable can be exported to another file or not.
Inline function
考虑如下场景，有一段代码很独立，适合抽成一个函数，但你又担心函数调用开销，此时inline function就是你的最佳选择。关于合适使用inline function，下面这段话给了一定的意见：

For functions that are large and/or perform complex tasks, the overhead of the function call is typically insignificant compared to the amount of time the function takes to run. However, for small functions, the overhead costs can be larger than the time needed to actually execute the function’s code! In cases where a small function is called often, using a function can result in a significant performance penalty over writing the same code in-place.

Inline function的好处包括：

没有函数调用的开销
编译器对展开后的代码有更大的优化空间（如常量替换）

However, inline expansion has its own potential cost: if the body of the function being expanded takes more instructions than the function call being replaced, then each inline expansion will cause the executable to grow larger. Larger executables tend to be slower (due to not fitting as well in caches).

注意：inline只是对编译器的一个建议，是否会真的展开取决于编译器的优化策略。

However, in modern C++, the inline keyword is no longer used to request that a function be expanded inline. There are quite a few reasons for this:

Using inline to request inline expansion is a form of premature optimization, and misuse could actually harm performance.
The inline keyword is just a hint &ndash; the compiler is completely free to ignore a request to inline a function. This is likely to be the result if you try to inline a lengthy function! The compiler is also free to perform inline expansion of functions that do not use the inline keyword  as part of its normal set of optimizations.
The inline keyword is defined at the wrong level of granularity. We use the inline keyword on a function declaration, but inline expansion is actually determined per function call. It may be beneficial to expand some function calls and detrimental to expand others, and there is no syntax to affect this.

注意：在modern cpp中，用inline修饰的不违反ODR（one definition rule），因此可用于

头文件中修饰常量作为global const的最佳方案1
头文件中修饰constexpr函数2使所有include该文件的源文件都能使用该函数，注意constexpr函数是默认inline的


Allowing functions with a constexpr return type to be evaluated at either compile-time or runtime was allowed so that a single function can serve both cases. Otherwise, you’d need to have separate functions (a constexpr version and a non-constexpr version) &ndash; and since return type isn’t considered in function overload resolution, you’d have to name the functions different things!
A constexpr function that is eligible to be evaluated at compile-time will only be evaluated at compile-time if the return value is used where a constant expression is required. Otherwise, compile-time evaluation is not guaranteed.
Thus, a constexpr function is better thought of as “can be used in a constant expression”, not “will be evaluated at compile-time”.

Unnamed namespace
An unnamed namespace (also called an anonymous namespace) is a namespace that is defined without a name, like so:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16


#include <iostream>

namespace // unnamed namespace
{
    void doSomething() // can only be accessed in this file
    {
        std::cout << &#34;v1\n&#34;;
    }
}

int main()
{
    doSomething(); // we can call doSomething() without a namespace prefix

    return 0;
}


特点：

All content declared in an unnamed namespace is treated as if it is part of the parent namespace.
All identifiers inside an unnamed namespace are treated as if they had internal linkage.

解决的问题：Unnamed namespaces will also keep user-defined types (something we’ll discuss in a later lesson) local to the file, something for which there is no alternative equivalent mechanism to do.
About switch clause
Put another way, defining a variable without an initializer is just telling the compiler that the variable is now in scope from that point on. This happens at compile time, and doesn’t require the definition to actually be executed at runtime.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19


int calculate(int x, int y, char op)
{
    int ret = 0;
    switch (op)
    {
    case '+':
        return x + y;
        case '-':
        return x - y;
        case '*':
        return x * y;
        case '/':
        return x / y;
        case '%':
        return x % y;
        default:
        throw std::invalid_arguments(&#34;invalid operator&#34;);
    }
}


Pointer to functions
The syntax for creating a non-const function pointer is one of the ugliest things you will ever see in C++:
// fcnPtr is a pointer to a function that takes no arguments and returns an integer
int (*fcnPtr)();
In the above snippet, fcnPtr is a pointer to a function that has no parameters and returns an integer. fcnPtr can point to any function that matches this type.
To make a const function pointer, the const goes after the asterisk:
int (*const fcnPtr)();
If you put the const before the int, then that would indicate the function being pointed to would return a const int."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Yychi's Blog</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/search/><li class=mobile-menu-item>Search</li></a><a href=/links/><li class=mobile-menu-item>More</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tricks/><li class=mobile-menu-item>Tricks</li></a><a href=/sketch/><li class=mobile-menu-item>Sketch</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Yychi's Blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/search/>Search</a></li><li class=menu-item><a class=menu-item-link href=/links/>More</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tricks/>Tricks</a></li><li class=menu-item><a class=menu-item-link href=/sketch/>Sketch</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>C++ 学习笔记</h1><div class=post-meta><span class=post-time>August 28, 2019</span><div class=post-category><a href=/categories/tech/>tech</a></div><span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> times read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#reactor-vs-proactor>Reactor v.s. Proactor</a></li><li><a href=#几个常用的宏>几个常用的宏</a></li><li><a href=#不要在ctor里调用虚函数>不要在ctor里调用虚函数</a></li><li><a href=#ctor不能是虚函数>ctor不能是虚函数</a></li><li><a href=#虚函数的工作原理>虚函数的工作原理</a></li><li><a href=#常见类型所占空间大小>常见类型所占空间大小</a></li><li><a href=#静态成员的初始化>静态成员的初始化</a></li><li><a href=#析构函数的调用时机>析构函数的调用时机</a></li><li><a href=#常量>常量</a><ul><li><a href=#literal-constants>Literal constants</a></li><li><a href=#symbolic-constants>Symbolic constants</a></li><li><a href=#object-like-preprocessor-macros-vs-symbolic-constants>Object-like preprocessor macros v.s. symbolic constants</a></li><li><a href=#using-symbolic-constants-throughout-a-multi-file-program>Using symbolic constants throughout a multi-file program</a></li></ul></li><li><a href=#内存布局>内存布局</a><ul><li><a href=#结构体>结构体</a></li><li><a href=#对齐>对齐</a></li></ul></li><li><a href=#模板>模板</a><ul><li><a href=#重载与特化>重载与特化</a></li></ul></li><li><a href=#预编译>预编译</a><ul><li><a href=#include><code>#include</code></a></li><li><a href=#macro-defines>Macro defines</a></li><li><a href=#object-like-macros-dont-affect-other-preprocessor-directives>Object-like macros don’t affect other preprocessor directives</a></li><li><a href=#the-scope-of-defines>The scope of defines</a></li></ul></li><li><a href=#header-files>Header files</a><ul><li><a href=#use-of-header-files>Use of header files</a></li><li><a href=#two-wrong-cases>Two wrong cases</a></li></ul></li><li><a href=#a-view-of-memory-and-fundamental-data-types-in-cpp>A view of memory and fundamental data types in cpp</a><ul><li><a href=#移位>移位</a></li><li><a href=#字节序>字节序</a></li></ul></li><li><a href=#链接linkage>链接（Linkage）</a><ul><li><a href=#external-linkage>External linkage</a></li></ul></li><li><a href=#inline-function>Inline function</a></li><li><a href=#unnamed-namespace>Unnamed namespace</a></li><li><a href=#pointer-to-functions>Pointer to functions</a></li><li><a href=#calling-a-function-using-a-function-pointer>Calling a function using a function pointer</a></li><li><a href=#references>References</a></li></ul></nav></div></div><div class=post-content><p>诚如是，Life is too short to learn c++. 此篇记录一些我在学习cpp过程中遇到的一些知识点，仅作记录并梳理之效。里面可能会有大量参考其他网络博客，如有侵权，请联系我删除之。</p><h2 id=reactor-vs-proactor>Reactor v.s. Proactor</h2><ul><li>epll/wait: reactor模式，不停轮询，发现有事做，就做！</li><li>asio: proactor模式，先注册好事件，如果事情发生了，通过回调函数处理。</li></ul><h2 id=几个常用的宏>几个常用的宏</h2><ul><li><code>__func__</code>: name of an function, exists in C99/C++11 (<code>__FUNCTION__</code> is non standard)</li><li><code>__LINE__</code>: line number of the code</li><li><code>__FILE__</code>: filename of the file</li><li><code>__DATE__</code> and <code>__TIME__</code>: as you wish</li></ul><h2 id=不要在ctor里调用虚函数>不要在ctor里调用虚函数</h2><p>总结来说：基类部分在派生类部分之前被构造，当基类构造函数执行时派生类中的数据成员还没被初始化。如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug。</p><p>ctor应该设计的尽量简单，确保对象可以被正确构造。在ctor中调用本类的非静态成员都是不安全的，因为他们还没被构造，而有些成员是依赖对象的，而此时对象还没有被成功构造。</p><h2 id=ctor不能是虚函数>ctor不能是虚函数</h2><ol><li><p>从存储空间角度：虚函数对应一个vtable（虚函数表），这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。</p></li><li><p>从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。
虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p></li><li><p>构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p></li></ol><p>——————————————————
版权声明：本文为CSDN博主「cainiao000001」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/cainiao000001/article/details/81603782</p><h2 id=虚函数的工作原理>虚函数的工作原理</h2><p><a href=https://zhuanlan.zhihu.com/p/60543586>https://zhuanlan.zhihu.com/p/60543586</a></p><p>C++ 规定了虚函数的行为，但将实现方法留给了编译器的作者。不需要知道实现方法也可以很好的使用虚函数，但了解虚函数的工作原理有助于更好地理解概念。</p><p>通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。</p><p>这种数组称为虚函数表（Virtual Function Table, vtbl）。</p><p>虚函数表是一个数组，数组的元素是指针，指针指的是虚函数的地址。</p><p>具有虚函数的类的实例，都会在头部存一个指向虚函数表的指针。</p><h2 id=常见类型所占空间大小>常见类型所占空间大小</h2><table><thead><tr><th>TYPE</th><th style=text-align:right>Bytes</th></tr></thead><tbody><tr><td>(unsigned) int</td><td style=text-align:right>4</td></tr><tr><td>(unsigned) short</td><td style=text-align:right>2</td></tr><tr><td>(unsigned) long</td><td style=text-align:right>8</td></tr><tr><td>float</td><td style=text-align:right>4</td></tr><tr><td>double</td><td style=text-align:right>8</td></tr><tr><td>long double</td><td style=text-align:right>16</td></tr><tr><td>(unsigned) char</td><td style=text-align:right>1</td></tr><tr><td>bool</td><td style=text-align:right>1</td></tr></tbody></table><p>指针占几个字节 指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关，譬如以前是16为地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就为8个字节。</p><blockquote><p>NOTE: 类成员函数指针一般为普通指针的两倍大小。</p></blockquote><p>literal <code>5.0</code>类型为<code>double</code>，<code>5.0f</code>类型为<code>float</code>。不加<code>f</code>后缀默认<code>double</code>.</p><h2 id=静态成员的初始化>静态成员的初始化</h2><p>当一个类包含静态成员时，最好的做法是在类中声明，在类外初始化。由于静态成员是所有对象共享的，如果在类内初始化，则每个对象构造时，都要执行一遍静态成员的初始化，这无疑是一种浪费。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>A</span><span class=o>::</span><span class=n>a</span> <span class=o>=</span> <span class=mi>233</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=n>string</span> <span class=n>str_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>done_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>B</span><span class=o>::</span><span class=n>str_</span> <span class=o>=</span> <span class=s>&#34;hello, i am static&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=析构函数的调用时机>析构函数的调用时机</h2><p>The destructor is called whenever an object&rsquo;s lifetime ends, which includes</p><ul><li>program termination, for objects with static storage duration</li><li>thread exit, for objects with thread-local storage duration</li><li>end of scope, for objects with automatic storage duration and for temporaries whose life was extended by binding to reference</li><li>delete-expressin, for objects with dynamic storage duration</li><li>end of the full expression, for nameless temporaries</li><li>stack unwinding (栈回溯), for objects with automatic storage duration when an exception escapes their block, uncaught.</li></ul><p>cf. <a href=https://en.cppreference.com/w/cpp/language/destructor>https://en.cppreference.com/w/cpp/language/destructor</a></p><h2 id=常量>常量</h2><h3 id=literal-constants>Literal constants</h3><p>字面值常量
Cf. <a href=https://www.learncpp.com/cpp-tutorial/literals/>https://www.learncpp.com/cpp-tutorial/literals/</a></p><h3 id=symbolic-constants>Symbolic constants</h3><p>符号常量
Cf. <a href=https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/>https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/</a></p><ol><li>Const variables must be initialized</li><li>Function parameters for arguments passed by value should not be made const.</li><li>Don’t use const with return by value.</li></ol><p><strong>Runtime vs compile-time constants</strong></p><p>Runtime constants are constants whose initialization values can only be resolved at runtime (when your program is running). The following are examples of runtime constants:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>printInt</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=c1>// x is a runtime constant because the value isn&#39;t known until the program is run
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Enter your age: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>age</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>usersAge</span> <span class=p>{</span> <span class=n>age</span> <span class=p>};</span> <span class=c1>// usersAge is a runtime constant because the value isn&#39;t known until the program is run
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Your age is: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printInt</span><span class=p>(</span><span class=n>age</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Compile-time constants are constants whose initialization values can be determined at compile-time (when your program is compiling). The following are examples of compile-time constants:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>double</span> <span class=n>gravity</span> <span class=p>{</span> <span class=mf>9.8</span> <span class=p>};</span> <span class=c1>// the compiler knows at compile-time that gravity will have value 9.8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=n>something</span> <span class=p>{</span> <span class=mi>1</span> <span class=o>+</span> <span class=mi>2</span> <span class=p>};</span> <span class=c1>// the compiler can resolve this at compiler time
</span></span></span></code></pre></td></tr></table></div></div><p>Compile-time constants enable the compiler to perform optimizations that aren’t available with runtime constants. For example, whenever gravity is used, the compiler can simply substitute the identifier gravity with the literal double 9.8.</p><p>To help provide more specificity, C++11 introduced the keyword <code>constexpr</code>, which ensures that a constant must be a compile-time constant.</p><blockquote><p>Any variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as <code>constexpr</code>.</p><p>Any variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as <code>const</code>.</p></blockquote><p>Note that literals are also implicitly constexpr, as the value of a literal is known at compile-time.</p><p>A <strong>constant expression</strong> is an expression that can be evaluated at compile-time. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=mi>3</span> <span class=o>+</span> <span class=mi>4</span><span class=p>;</span> <span class=c1>// 3 + 4 evaluated at compile-time
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>In the above program, because the literal values 3 and 4 are known at compile-time, the compiler can evaluate the expression 3 + 4 at compile-time and substitute in the resulting value 7. That makes the code faster because 3 + 4 no longer has to be calculated at runtime.</p><p>Constexpr variables can also be used in constant expressions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>constexpr</span> <span class=kt>int</span> <span class=n>x</span> <span class=p>{</span> <span class=mi>3</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=k>constexpr</span> <span class=kt>int</span> <span class=n>y</span> <span class=p>{</span> <span class=mi>4</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span> <span class=c1>// x + y evaluated at compile-time
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>In the above example, because x and y are constexpr, the expression x + y is a constant expression that can be evaluated at compile-time. Similar to the literal case, the compiler can substitute in the value 7.</p><h3 id=object-like-preprocessor-macros-vs-symbolic-constants>Object-like preprocessor macros v.s. symbolic constants</h3><p>Object-like macro has the form:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define identifier substitution_text
</span></span></span></code></pre></td></tr></table></div></div><p>Whenever the preprocessor encounters this directive, any further occurrence of <em>identifier</em> is replaced by <em>substitution_text</em>. The identifier is traditionally typed in all capital letters, using underscores to represent spaces.</p><blockquote><p>Avoid using #define to create symbolic constants macros. Use const or constexpr variables instead.</p></blockquote><p>Macros can have naming conflicts with normal code. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;someheader.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>beta</span> <span class=p>{</span> <span class=mi>5</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>beta</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>If someheader.h happened to #define a macro named beta, this simple program would break, as the preprocessor would replace the int variable beta’s name with whatever the macro’s value was. This is normally avoided by using all caps for macro names, but it can still happen.</p><h3 id=using-symbolic-constants-throughout-a-multi-file-program>Using symbolic constants throughout a multi-file program</h3><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/>https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/</a></p><h2 id=内存布局>内存布局</h2><h3 id=结构体>结构体</h3><p>C++规范在“结构”上使用了和C相同的，简单的内存布局原则：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>S</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>a</span><span class=p>;</span>     <span class=c1>// memory location #1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nl>b</span> <span class=p>:</span> <span class=mi>5</span><span class=p>;</span>  <span class=c1>// memory location #2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nl>c</span> <span class=p>:</span> <span class=mi>11</span><span class=p>,</span> <span class=c1>// memory location #2 (continued)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span>  <span class=o>:</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nl>d</span> <span class=p>:</span> <span class=mi>8</span><span class=p>;</span>  <span class=c1>// memory location #3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=nl>ee</span> <span class=p>:</span> <span class=mi>8</span><span class=p>;</span> <span class=c1>// memory location #4
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>obj</span><span class=p>;</span> <span class=c1>// The object &#39;obj&#39; consists of 4 separate memory locations
</span></span></span></code></pre></td></tr></table></div></div><ul><li>类的静态成员不占用类的空间，静态成员在程序数据段中。</li></ul><h3 id=对齐>对齐</h3><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/#comment-563585>https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/#comment-563585</a></p><p>Cf. <a href=http://www.catb.org/esr/structure-packing/>http://www.catb.org/esr/structure-packing/</a></p><h2 id=模板>模板</h2><h3 id=重载与特化>重载与特化</h3><p>从编译到函数模板的调用，编译器必须在非模板重载、模板重载和模板重载的特化间决定。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>T</span> <span class=o>&gt;</span> <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>              <span class=c1>// #1 ：模板重载
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>T</span> <span class=o>&gt;</span> <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=o>*</span><span class=p>);</span>             <span class=c1>// #2 ：模板重载
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>                     <span class=nf>f</span><span class=p>(</span><span class=kt>double</span><span class=p>);</span>         <span class=c1>// #3 ：非模板重载
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;&gt;</span>          <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>            <span class=c1>// #4 ： #1 的特化
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>);</span>        <span class=c1>// 调用 #1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span> <span class=c1>// 调用 #2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=mf>1.0</span><span class=p>);</span>        <span class=c1>// 调用 #3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>          <span class=c1>// 调用 #4
</span></span></span></code></pre></td></tr></table></div></div><p>注意只有非模板和初等模板重载参与重载决议。特化不是重载，且不受考虑。只有在重载决议选择最佳匹配初等函数模板后，才检验其特化以查看何为最佳匹配。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>T</span> <span class=o>&gt;</span> <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>    <span class=c1>// #1 ：所有类型的重载
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;&gt;</span>          <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span> <span class=c1>// #2 ：为指向 int 的指针特化 #1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>T</span> <span class=o>&gt;</span> <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=o>*</span><span class=p>);</span>   <span class=c1>// #3 ：所有指针类型的重载
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span> <span class=c1>// 调用 #3 ，即使通过 #1 的特化会是完美匹配
</span></span></span></code></pre></td></tr></table></div></div><p>即重载的优先级要高于特化。</p><p>关于模板函数重载的更多内容，参考<a href=https://en.cppreference.com/w/cpp/language/function_template>function_template</a>。</p><h2 id=预编译>预编译</h2><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/>https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/</a></p><h3 id=include><code>#include</code></h3><p>When you #include a file, the preprocessor replaces the #include directive with the contents of the included file. The included contents are then preprocessed (along with the rest of the file), and then compiled.</p><h3 id=macro-defines>Macro defines</h3><p>The #define directive can be used to create a macro. In C++, a macro is a rule that defines how input text is converted into replacement output text.</p><p>There are two basic types of macros: <em>object-like macros</em>, and <em>function-like macros</em>.
Object-like macros can be defined in one of two ways:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define identifier
</span></span></span><span class=line><span class=cl><span class=cp>#define identifier substitution_text
</span></span></span></code></pre></td></tr></table></div></div><h3 id=object-like-macros-dont-affect-other-preprocessor-directives>Object-like macros don’t affect other preprocessor directives</h3><p>结论：宏展开在预编译指令(Preprocessor directives)无效。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define PRINT_JOE
</span></span></span><span class=line><span class=cl><span class=cp>#ifdef PRINT_JOE    </span><span class=c1>// 此处会否将&#39;PRINT_JOE&#39;替换为空呢？
</span></span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span></code></pre></td></tr></table></div></div><p>Macros only cause text substitution for normal code. Other preprocessor commands are ignored. Consequently, the PRINT_JOE in #ifdef PRINT_JOE is left alone.</p><p>For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define FOO 9 </span><span class=c1>// Here&#39;s a macro substitution
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef FOO </span><span class=c1>// This FOO does not get replaced because it’s part of another preprocessor directive
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>FOO</span><span class=p>;</span> <span class=c1>// This FOO gets replaced with 9 because it&#39;s part of the normal code
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#endif
</span></span></span></code></pre></td></tr></table></div></div><p>In actuality, the output of the preprocessor contains no directives at all &ndash; they are all resolved/stripped out before compilation, because the compiler wouldn’t know what to do with them.</p><h3 id=the-scope-of-defines>The scope of defines</h3><p>Once the preprocessor has finished, all defined identifiers from that file are discarded. <strong>This means that directives are only valid from the point of definition to the end of the file in which they are defined</strong>. Directives defined in one code file do not have impact on other code files in the same project.</p><p>宏定义仅在本文件有效，一旦预编译阶段结束，所有宏都将失效。因为，预编译就是将所有的预编译指令都处理掉，该替换的替换（宏展开），该选择的选择，该丢弃的丢弃（条件编译），然后交给编译器去编译，谨记：编译器是读不懂预编译指令的！</p><p>Consider the following example:</p><p>function.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>doSomething</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef PRINT
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Printing!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#ifndef PRINT
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Not printing!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>main.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>doSomething</span><span class=p>();</span> <span class=c1>// forward declaration for function doSomething()
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#define PRINT
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>doSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The above program will print:</p><pre tabindex=0><code>Not printing!
</code></pre><p>Even though PRINT was defined in main.cpp, that doesn’t have any impact on any of the code in function.cpp (PRINT is only #defined from the point of definition to the end of main.cpp). This will be of consequence when we discuss header guards in a future lesson.</p><h2 id=header-files>Header files</h2><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/header-files/>https://www.learncpp.com/cpp-tutorial/header-files/</a></p><p>对于多文件项目，文件是单独编译的。要想调用一个自定义函数，linker必须能找到这个函数在哪里定义。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>  <span class=c1>// forward declaration
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// add(3, 5);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>上述文件是可以编译通过的，因为没有发生对<code>add</code>的调用，所以linker不会去找<code>add</code>的定义（当然如果要找也找不到）。</p><p>但是如果某处发起了对<code>add</code>的调用（例如去掉注释），那么上述程序在link阶段会报错：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>yychi@~&gt; clang test_linker.cpp
</span></span><span class=line><span class=cl>/usr/bin/ld: /tmp/test_linker-e1bb8b.o: in <span class=k>function</span> <span class=sb>`</span>main<span class=s1>&#39;:
</span></span></span><span class=line><span class=cl><span class=s1>test_linker.cpp:(.text+0x1a): undefined reference to `add(int, int)&#39;</span>
</span></span><span class=line><span class=cl>clang-13: error: linker <span class=nb>command</span> failed with <span class=nb>exit</span> code <span class=m>1</span> <span class=o>(</span>use -v to see invocation<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>在多文件编程时，往往需要forawrd declaration，这些前置声明必须在其他某个地方被定义且只被定义一次。这样，linker才能正确的完成链接。任何重复定义或未定义都会在link阶段报错。</p><p>考虑如下例子：</p><p>add.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>main.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>z</span> <span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;z=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>z</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在编译main.cpp的时候，因为有<code>add</code>的前置声明，所以可以通过。但为了link的时候能够找到<code>add</code>的定义，add.cpp必须也被编译，所以正确的编译方式应该是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ clang main.cpp add.cpp
</span></span></code></pre></td></tr></table></div></div><h3 id=use-of-header-files>Use of header files</h3><p>从上面的论述我们隐约可见，在多文件编程中，我们可能会大量的使用前置声明（forward declaration），一旦文件多起来，这将非常枯燥。所以头文件的出现就是为了解决这个问题：把所有的声明放在一起。</p><p>Let’s write a header file to relieve us of this burden. Writing a header file is surprisingly easy, as header files only consist of two parts:</p><ol><li>A header guard.</li><li>The actual content of the header file, which should be the forward declarations for all of the identifiers we want other files to be able to see.</li></ol><p>add.h:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 1) We really should have a header guard here, but will omit it for simplicity (we&#39;ll cover header guards in the next lesson)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 2) This is the content of the .h file, which is where the declarations go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>);</span> <span class=c1>// function prototype for add.h -- don&#39;t forget the semicolon!
</span></span></span></code></pre></td></tr></table></div></div><p>main.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;add.h&#34; // Insert contents of add.h at this point.  Note use of double quotes here.</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;The sum of 3 and 4 is &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>add.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;add.h&#34; // Insert contents of add.h at this point.  Note use of double quotes here.</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>When the preprocessor processes the <code>#include "add.h"</code> line, it copies the contents of <em>add.h</em> into the current file at that point. Because our <em>add.h</em> contains a forward declaration for function <em>add</em>, that forward declaration will be copied into <em>main.cpp</em>. The end result is a program that is functionally the same as the one where we manually added the forward declaration at the top of <em>main.cpp</em>.</p><p>Consequently, our program will compile and link correctly.
<img src="https://www.learncpp.com/images/CppTutorial/Section1/IncludeHeader.png?ezimgfmt=rs:647x377/rscb2/ng:webp/ngcb2" alt></p><h3 id=two-wrong-cases>Two wrong cases</h3><p><img src=wrong_header.png alt="header has function definition"></p><p>如上图所示，会产生一个重复定义的错误。由于add.h中包含了函数定义，而非前置声明。编译main.cpp的时候，add.h中的代码插入到main.cpp中，产生一次<code>add</code>函数的定义。同理，编译add.cpp的时候也定义了一次<code>add</code>函数。link阶段会发生歧义，以致报错。</p><p>此时如果不编译add.cpp其实是可行的：
<img src=header2.png alt="compile main.cpp only"></p><p>但谁又能保证只有一个文件<code>#include "add.h"</code>呢？所以头文件中应该只包含声明，而不应该包含实现。</p><blockquote><p>The primary purpose of a header file is to propagate declarations to code files.</p></blockquote><p>Key insight: Header files allow us to put declarations in one location and then import them wherever we need them. This can save a lot of typing in multi-file programs.</p><p>Header files should generally not contain function and variable definitions, so as not to violate the one definition rule. An exception is made for symbolic constants (which we cover in lesson <a href=https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/>4.15 &ndash; Symbolic constants: const and constexpr variables</a>).</p><p><strong>标准库自动链接</strong></p><blockquote><p>注意：clang不会自动链接，需要手动链接
<code>clang main.cpp -lstdc++</code></p></blockquote><p>When it comes to functions and variables, it’s worth keeping in mind that header files typically only contain function and variable declarations, not function and variable definitions (otherwise a violation of the one definition rule could result). std::cout is forward declared in the iostream header, but defined as part of the C++ standard library, which is automatically linked into your program during the linker phase.</p><p><img src=cout.png alt=cout></p><p><strong>The #include order of header files</strong></p><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/header-files/>https://www.learncpp.com/cpp-tutorial/header-files/</a> for &ldquo;the #inclue order of header files&rdquo;.</p><h2 id=a-view-of-memory-and-fundamental-data-types-in-cpp>A view of memory and fundamental data types in cpp</h2><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/>https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/</a></p><p>The smallest unit of memory is a binary digit (also called a bit), which can hold a value of 0 or 1. You can think of a bit as being like a traditional light switch &ndash; either the light is off (0), or it is on (1). There is no in-between. If you were to look at a random segment of memory, all you would see is …011010100101010… or some combination thereof.</p><p>Memory is organized into sequential units called memory addresses (or addresses for short). Similar to how a street address can be used to find a given house on a street, the memory address allows us to find and access the contents of memory at a particular location.</p><p>Perhaps surprisingly, in modern computer architectures, each bit does not get its own unique memory address. This is because the number of memory addresses are limited, and the need to access data bit-by-bit is rare. Instead, each memory address holds 1 byte of data. A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.</p><p><strong>Data types</strong></p><p>Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way. You have already seen one example of a data type: the integer. When we declare a variable as an integer, we are telling the compiler “the piece of memory that this variable uses is going to be interpreted as an integer value”.</p><p>When you give an object a value, the compiler and CPU take care of encoding your value into the appropriate sequence of bits for that data type, which are then stored in memory (<strong>remember: memory can only store bits</strong>). For example, if you assign an integer object the value 65, that value is converted to the sequence of bits 0100 0001 and stored in the memory assigned to the object.</p><p>Conversely, when the object is evaluated to produce a value, that sequence of bits is reconstituted back into the original value. Meaning that 0100 0001 is converted back into the value 65.</p><p>Fortunately, the compiler and CPU do all the hard work here, so you generally don’t need to worry about how values get converted into bit sequences and back.</p><p>All you need to do is pick a data type for your object that best matches your desired use.</p><p>谨记：内存只能存bit，只能寻址寻到byte这一层，如果数据按内存边界对齐，寻址会更快（一次读）。</p><p>由于内存地址空间有限，且按bit寻址的场景很少，所以寻址单位一般是byte。A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.</p><h3 id=移位>移位</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdint&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>int32_t</span> <span class=n>a</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>b</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>n_shift</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;a=&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;; b=&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;left shift &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n_shift</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; bit(s) of a is: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>n_shift</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;left shift &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n_shift</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; bit(s) of b is: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>n_shift</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;right shift &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n_shift</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; bit(s) of a is: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>a</span> <span class=o>&gt;&gt;</span> <span class=n>n_shift</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;right shift &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n_shift</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; bit(s) of b is: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>b</span> <span class=o>&gt;&gt;</span> <span class=n>n_shift</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int32_t</span> <span class=n>a</span> <span class=o>=</span> <span class=mh>0xffffffff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>b</span> <span class=o>=</span> <span class=mh>0xffffffff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;------------</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=mh>0xbfffffff</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Output on my machine:
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>a=-1; b=4294967295
</span></span></span><span class=line><span class=cl><span class=cm>left shift 1 bit(s) of a is: -2
</span></span></span><span class=line><span class=cl><span class=cm>left shift 1 bit(s) of b is: 4294967294
</span></span></span><span class=line><span class=cl><span class=cm>right shift 1 bit(s) of a is: -1
</span></span></span><span class=line><span class=cl><span class=cm>right shift 1 bit(s) of b is: 2147483647
</span></span></span><span class=line><span class=cl><span class=cm>------------
</span></span></span><span class=line><span class=cl><span class=cm>a=-1073741825; b=4294967295
</span></span></span><span class=line><span class=cl><span class=cm>left shift 1 bit(s) of a is: 2147483646
</span></span></span><span class=line><span class=cl><span class=cm>left shift 1 bit(s) of b is: 4294967294
</span></span></span><span class=line><span class=cl><span class=cm>right shift 1 bit(s) of a is: -536870913
</span></span></span><span class=line><span class=cl><span class=cm>right shift 1 bit(s) of b is: 2147483647
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></td></tr></table></div></div><p>从内存连续bit来看，a和b都是存了4 byte的1，区别仅仅是data type不一样，导致了截然不同的结果。</p><p><strong>移位操作</strong></p><ol><li>右移<ol><li>无符号右移，低位丢失高位补0</li><li>有符号右移，低位丢失，高位补符号位（正为0, 负为1）</li></ol></li><li>左移：高位丢失，低位补0</li></ol><p>a和b左移一位都得到：</p><pre tabindex=0><code>0xfffffffe: 如果是int解释为-2, unsigned int解释为4294967294=2^32 - 2
</code></pre><p>a右移一位得到</p><pre tabindex=0><code>0xffffffff: 注意负数右移，高位补1，int解释为-1
</code></pre><p>b右移一位得到</p><pre tabindex=0><code>0x7fffffff: 高位补0, unsigned int解释为2147483647=2^31-1
</code></pre><p>注意，负的可能左移成正的，因此，有符号的移位是不安全的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>signed</span> <span class=kt>int</span> <span class=n>s</span> <span class=p>{</span> <span class=o>-</span><span class=mi>1</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>u</span> <span class=p>{</span> <span class=mi>1</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>&lt;</span> <span class=n>u</span><span class=p>)</span> <span class=c1>// -1 is implicitly converted to 4294967295, and 4294967295 &lt; 1 is false
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;-1 is less than 1</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;1 is less than -1</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=c1>// this statement executes
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>NOTE:</p><ol><li>注意无符号数相减得负数会导致溢出</li><li>usigned和<code>--</code>运算符，可能减至负数溢出</li><li>除非确定变量值非负，否则尽量避免使用unsigned</li><li>切忌不要在数学计算中混用unsigned和signed，此时signed会隐式转换为unsigned</li><li>unsigned numbers are preferred when dealing with bit manipulation</li><li><code>std::int8_t</code>和<code>std::uint8_t</code>可能知识<code>char</code>和<code>unsigned char</code>的别名，可能有坑（参考：https://www.learncpp.com/cpp-tutorial/introduction-to-type-conversion-and-static_cast/）</li></ol><p><strong>Best practice</strong></p><p>Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.</p><h3 id=字节序>字节序</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * This file test the endian of your machine:
</span></span></span><span class=line><span class=cl><span class=cm> * big-endian or little-endian, by visiting
</span></span></span><span class=line><span class=cl><span class=cm> * the memory sequentially byte by byte of
</span></span></span><span class=line><span class=cl><span class=cm> * a intendly constructed integer.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdint&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// convert to char* so we can visit the memory byte by byte
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>_ptr</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// print the value of each byte in ptr
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>_ptr</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>a</span> <span class=o>=</span> <span class=mh>0x01020304</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * if it prints 4321, indicates 低位在前，对应little-endian
</span></span></span><span class=line><span class=cl><span class=cm>     * it it prints 1234, indicates 高位在前，对应big-endian
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Output on my machine
</span></span></span><span class=line><span class=cl><span class=cm>4321
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></td></tr></table></div></div><p>字节序就是计算机存储数据的时候将低位数据存在低位地址还是高位地址。举个例子，数值0x2211使用两个字节储存：高位字节是0x22，低位字节是0x11。</p><ul><li>大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。</li><li>小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。</li></ul><p>如果太多记不住，至少要记住：</p><ol><li>字节序的概念: 读一段内存从低位向高位读（从左往右），先读到高位字节还是低位字节</li><li>符合人类读写数值的方法是大端序（big-endian）</li></ol><p>既然如此，我们要判断一台机器是big-endian还是little-endian，只需要构造一端内存，按字节从低位地址向高位地址访问，看看低位地址存的是高位字节，还是低位字节即可。</p><p>且看上述代码，构造了一个整数0x01020304，然后通过将首地址转成<code>char*</code>的方式去按字节读取内存中的值（这样做的目的是，<code>char*</code>可以逐字节的读取内存；而<code>int*</code>一次指针移动会移动<code>sizeof(int)</code>个字节）。读出来如果是符合书写习惯的1234, 则表明机器是big-endian, 反之little-endian.</p><p>这也是一段内存的两种不同的解释方式，recall that <strong>Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way</strong>.</p><h2 id=链接linkage>链接（Linkage）</h2><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/internal-linkage/>https://www.learncpp.com/cpp-tutorial/internal-linkage/</a></p><p>Identifiers have another property named <code>linkage</code>. An identifier’s <strong>linkage</strong> determines whether other declarations of that name refer to the same object or not.</p><p>Local variables have <code>no linkage</code>, which means that each declaration refers to a unique object.</p><p>Global variable and functions identifiers can have either <code>internal linkage</code> or <code>external linkage</code>.</p><p>An identifier with <strong>internal linkage</strong> can be seen and used within a single file, but it is not accessible from other files (that is, it is not exposed to the linker). This means that if two files have identically named identifiers with internal linkage, those identifiers will be treated as independent.</p><p>To make a non-constant global variable internal, we use the static keyword.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>g_x</span><span class=p>;</span> <span class=c1>// non-constant globals have external linkage by default, but can be given internal linkage via the static keyword
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span> <span class=p>{</span> <span class=mi>1</span> <span class=p>};</span> <span class=c1>// const globals have internal linkage by default
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>g_z</span> <span class=p>{</span> <span class=mi>2</span> <span class=p>};</span> <span class=c1>// constexpr globals have internal linkage by default
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>To see it, we take</p><p>a.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_x</span> <span class=o>=</span> <span class=mi>22</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span> <span class=o>=</span> <span class=mi>33</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>g_z</span> <span class=o>=</span> <span class=mi>44</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>main.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_x</span> <span class=o>=</span> <span class=mi>222</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span> <span class=o>=</span> <span class=mi>333</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>g_z</span> <span class=o>=</span> <span class=mi>444</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&#34;</span><span class=p>,</span> <span class=n>g_x</span><span class=p>,</span> <span class=n>g_y</span><span class=p>,</span> <span class=n>g_z</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>if we compile only main.cpp, it works fine and outputs:</p><pre tabindex=0><code>glabal variable (g_x, g_y, g_z) is (222, 333, 444)
</code></pre><p>But if we compile both, it gets</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ clang main.cpp a.cpp
</span></span><span class=line><span class=cl>/usr/bin/ld: /tmp/a-ea4f54.o:<span class=o>(</span>.data+0x0<span class=o>)</span>: multiple definition of <span class=sb>`</span>g_x<span class=err>&#39;</span><span class=p>;</span> /tmp/main-c44eb4.o:<span class=o>(</span>.data+0x0<span class=o>)</span>: first defined here
</span></span><span class=line><span class=cl>clang-13: error: linker <span class=nb>command</span> failed with <span class=nb>exit</span> code <span class=m>1</span> <span class=o>(</span>use -v to see invocation<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>As we sligtly modify main.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=n>g_x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span> <span class=o>=</span> <span class=mi>333</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>g_z</span> <span class=o>=</span> <span class=mi>444</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&#34;</span><span class=p>,</span> <span class=n>g_x</span><span class=p>,</span> <span class=n>g_y</span><span class=p>,</span> <span class=n>g_z</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>it&rsquo;s compiled and linked properly with the output:</p><pre tabindex=0><code>glabal variable (g_x, g_y, g_z) is (22, 333, 444)
</code></pre><p>noting that the <code>g_x</code> has the value 22 which is defined in a.cpp, we find out the global non-const variable has external linkage. And the properly compilation and linking show that global const has internal linkage.</p><h3 id=external-linkage>External linkage</h3><p>Cf. <a href=https://www.learncpp.com/cpp-tutorial/external-linkage/>https://www.learncpp.com/cpp-tutorial/external-linkage/</a></p><p>An identifier with <strong>external linkage</strong> can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration). In this sense, identifiers with external linkage are truly “global” in that they can be used anywhere in your program!</p><p><strong>Functions have external linkage by default</strong></p><p>In order to call a function defined in another file, you must place a <code>forward declaration</code> for the function in any other files wishing to use the function. <u>The forward declaration tells the compiler about the existence of the function, and the linker connects the function calls to the actual function definition.</u></p><p><strong>Global variables with external linkage</strong></p><p>Global variables with external linkage are sometimes called <strong>external variables</strong>. To make a global variable external (and thus accessible by other files), we can use the <code>extern</code> keyword to do so:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_x</span> <span class=p>{</span> <span class=mi>2</span> <span class=p>};</span> <span class=c1>// non-constant globals are external by default
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span> <span class=p>{</span> <span class=mi>3</span> <span class=p>};</span> <span class=c1>// const globals can be defined as extern, making them external
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>g_z</span> <span class=p>{</span> <span class=mi>3</span> <span class=p>};</span> <span class=c1>// constexpr globals can be defined as extern, making them external (but this is useless, see the note in the next section)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Non-const global variables are external by default (if used, the <code>extern</code> keyword will be ignored).</p><p>To actually use an external global variable that has been defined in another file, you also must place a <code>forward declaration</code> for the global variable in any other files wishing to use the variable. For variables, creating a forward declaration is also done via the <code>extern</code> keyword (with no initialization value).</p><p>Here is an example of using a variable forward declaration:</p><p>a.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// global variable definitions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>g_x</span> <span class=p>{</span> <span class=mi>2</span> <span class=p>};</span> <span class=c1>// non-constant globals have external linkage by default
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span> <span class=p>{</span> <span class=mi>3</span> <span class=p>};</span> <span class=c1>// this extern gives g_y external linkage
</span></span></span></code></pre></td></tr></table></div></div><p>main.cpp:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=n>g_x</span><span class=p>;</span> <span class=c1>// this extern is a forward declaration of a variable named g_x that is defined somewhere else
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span><span class=p>;</span> <span class=c1>// this extern is a forward declaration of a const variable named g_y that is defined somewhere else
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>g_x</span><span class=p>;</span> <span class=c1>// prints 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Note that the <code>extern</code> keyword has different meanings in different contexts. In some contexts, <code>extern</code> means “give this variable external linkage”. In other contexts, <code>extern</code> means “this is a forward declaration for an external variable that is defined somewhere else”.</p><p><strong>Summary</strong></p><p><em>Scope</em> determines where a variable is accessible. <em>Duration</em> determines where a variable is created and destroyed. <em>Linkage</em> determines whether the variable can be exported to another file or not.</p><h2 id=inline-function>Inline function</h2><p>考虑如下场景，有一段代码很独立，适合抽成一个函数，但你又担心函数调用开销，此时inline function就是你的最佳选择。关于合适使用inline function，下面这段话给了一定的意见：</p><blockquote><p>For functions that are large and/or perform complex tasks, the overhead of the function call is typically insignificant compared to the amount of time the function takes to run. However, for small functions, the overhead costs can be larger than the time needed to actually execute the function’s code! In cases where a small function is called often, using a function can result in a significant performance penalty over writing the same code in-place.</p></blockquote><p>Inline function的好处包括：</p><ol><li>没有函数调用的开销</li><li>编译器对展开后的代码有更大的优化空间（如常量替换）</li></ol><p>However, inline expansion has its own potential cost: if the body of the function being expanded takes more instructions than the function call being replaced, then each inline expansion will cause the executable to grow larger. Larger executables tend to be slower (due to not fitting as well in caches).</p><blockquote><p>注意：inline只是对编译器的一个建议，是否会真的展开取决于编译器的优化策略。</p></blockquote><p>However, in modern C++, the <code>inline</code> keyword is no longer used to request that a function be expanded inline. There are quite a few reasons for this:</p><ul><li>Using <code>inline</code> to request inline expansion is a form of premature optimization, and misuse could actually harm performance.</li><li>The <code>inline</code> keyword is just a hint &ndash; the compiler is completely free to ignore a request to inline a function. This is likely to be the result if you try to inline a lengthy function! <strong>The compiler is also free to perform inline expansion of functions that do not use the <code>inline</code> keyword</strong> as part of its normal set of optimizations.</li><li>The <code>inline</code> keyword is defined at the wrong level of granularity. We use the <code>inline</code> keyword on a function declaration, but inline expansion is actually determined per function call. It may be beneficial to expand some function calls and detrimental to expand others, and there is no syntax to affect this.</li></ul><p>注意：在modern cpp中，用inline修饰的不违反ODR（one definition rule），因此可用于</p><ul><li>头文件中修饰常量作为global const的最佳方案<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li>头文件中修饰constexpr函数<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>使所有include该文件的源文件都能使用该函数，注意constexpr函数是默认inline的</li></ul><blockquote><p>Allowing functions with a constexpr return type to be evaluated at either compile-time or runtime was allowed so that a single function can serve both cases. Otherwise, you’d need to have separate functions (a constexpr version and a non-constexpr version) &ndash; and since return type isn’t considered in function overload resolution, you’d have to name the functions different things!</p><p>A constexpr function that is eligible to be evaluated at compile-time will only be evaluated at compile-time if the return value is used where a constant expression is required. Otherwise, compile-time evaluation is not guaranteed.</p><p>Thus, a constexpr function is better thought of as “can be used in a constant expression”, not “will be evaluated at compile-time”.</p></blockquote><h2 id=unnamed-namespace>Unnamed namespace</h2><p>An <strong>unnamed namespace</strong> (also called an <strong>anonymous namespace</strong>) is a namespace that is defined without a name, like so:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=c1>// unnamed namespace
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>doSomething</span><span class=p>()</span> <span class=c1>// can only be accessed in this file
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;v1</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>doSomething</span><span class=p>();</span> <span class=c1>// we can call doSomething() without a namespace prefix
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>特点：</p><ol><li>All content declared in an unnamed namespace is treated as if it is part of the parent namespace.</li><li>All identifiers inside an unnamed namespace are treated as if they had <strong>internal linkage</strong>.</li></ol><p>解决的问题：Unnamed namespaces will also keep user-defined types (something we’ll discuss in a later lesson) local to the file, something for which there is no alternative equivalent mechanism to do.</p><p><strong>About <code>switch</code> clause</strong></p><p><em>Put another way, defining a variable without an initializer is just telling the compiler that the variable is now in scope from that point on. This happens at compile time, and doesn’t require the definition to actually be executed at runtime.</em></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>calculate</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>char</span> <span class=n>op</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>op</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=sc>&#39;+&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=sc>&#39;-&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>-</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=sc>&#39;*&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=sc>&#39;/&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>/</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=sc>&#39;%&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>%</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>invalid_arguments</span><span class=p>(</span><span class=s>&#34;invalid operator&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=pointer-to-functions>Pointer to functions</h2><p>The syntax for creating a non-const function pointer is one of the ugliest things you will ever see in C++:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// fcnPtr is a pointer to a function that takes no arguments and returns an integer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fcnPtr</span><span class=p>)();</span>
</span></span></code></pre></div><p>In the above snippet, fcnPtr is a pointer to a function that has no parameters and returns an integer. fcnPtr can point to any function that matches this type.</p><p>To make a const function pointer, the const goes after the asterisk:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=k>const</span> <span class=n>fcnPtr</span><span class=p>)();</span>
</span></span></code></pre></div><p>If you put the const before the int, then that would indicate the function being pointed to would return a const int.</p><p>Note that the type (parameters and return type) of the function pointer must match the type of the function. Here are some examples of this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// function prototypes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>goo</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>hoo</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// function pointer assignments
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fcnPtr1</span><span class=p>)(){</span> <span class=o>&amp;</span><span class=n>foo</span> <span class=p>};</span> <span class=c1>// okay
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fcnPtr2</span><span class=p>)(){</span> <span class=o>&amp;</span><span class=n>goo</span> <span class=p>};</span> <span class=c1>// wrong -- return types don&#39;t match!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=p>(</span><span class=o>*</span><span class=n>fcnPtr4</span><span class=p>)(){</span> <span class=o>&amp;</span><span class=n>goo</span> <span class=p>};</span> <span class=c1>// okay
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>fcnPtr1</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>hoo</span><span class=p>;</span> <span class=c1>// wrong -- fcnPtr1 has no parameters, but hoo() does
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fcnPtr3</span><span class=p>)(</span><span class=kt>int</span><span class=p>){</span> <span class=o>&amp;</span><span class=n>hoo</span> <span class=p>};</span> <span class=c1>// okay
</span></span></span></code></pre></td></tr></table></div></div><p>Unlike fundamental types, C++ <em>will</em> implicitly convert a function into a function pointer if needed (so you don&rsquo;t need to use the address-of operator (&) to get the function&rsquo;s address). However, it will not implicitly convert function pointers to void pointers, or vice-versa.</p><h2 id=calling-a-function-using-a-function-pointer>Calling a function using a function pointer</h2><p>The other primary thing you can do with a function pointer is use it to actually call the function. There are two ways to do this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=hl><span class=lnt>6
</span></span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fcnPtr</span><span class=p>)(</span><span class=kt>int</span><span class=p>){</span> <span class=o>&amp;</span><span class=n>foo</span> <span class=p>};</span> <span class=c1>// Initialize fcnPtr with function foo
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>(</span><span class=o>*</span><span class=n>fcnPtr</span><span class=p>)(</span><span class=mi>5</span><span class=p>);</span> <span class=c1>// call function foo(5) via explict dereference of fcnPtr.
</span></span></span><span class="line hl"><span class=cl><span class=c1></span>    <span class=n>fcnPtr</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span> <span class=c1>// call function foo(5) via implicit dereference of fcnPtr.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>As you can see, the implicit dereference method looks just like a normal function call &ndash; which is what you&rsquo;d expect, since <strong>normal function names are pointers to functions anyway</strong>! However, some older compilers do not support the implicit dereference method, but all modern compilers should.</p><blockquote><p>One interesting note: Default parameters won’t work for functions called through function pointers. Default parameters are resolved at compile-time (that is, if you don’t supply an argument for a defaulted parameter, the compiler substitutes one in for you when the code is compiled). However, function pointers are resolved at run-time. Consequently, default parameters can not be resolved when making a function call with a function pointer. You’ll explicitly have to pass in values for any defaulted parameters in this case.</p></blockquote><h2 id=references>References</h2><ol><li><a href=https://www.ruanyifeng.com/blog/2016/11/byte-order.html>理解字节序</a></li><li><a href=https://www.learncpp.com/cpp-tutorial/function-pointers/>12.1 — Function Pointers</a></li></ol><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/>6.9 — Sharing global constants across multiple files (using inline variables)</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://www.learncpp.com/cpp-tutorial/constexpr-and-consteval-functions/>6.14 — Constexpr and consteval functions</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Yychi</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>May 28, 2023</span></p><p class=copyright-item><span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/cpp/>cpp</a>
<a href=/tags/note/>note</a></div><nav class=post-nav><a class=prev href=/post/concurrent-programming/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">多线程学习笔记</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/post/blog-trans/><span class="next-text nav-default">博客迁移记录</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=vcomments></div><script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script>
<script src=//unpkg.com/valine/dist/Valine.min.js></script>
<script type=text/javascript>new Valine({el:"#vcomments",appId:"GiggnUHAwYrkisc4eEXrCuUu-gzGzoHsz",appKey:"fjzzXaIgPDyMlxqtN0oBWeNN",notify:!1,verify:!1,avatar:"mm",placeholder:"ヾﾉ≧∀≦)o来啊，快活啊!",visitor:!1})</script></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:guyueshui002@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/guyueshui class="iconfont icon-github" title=github></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>site pv: <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span></span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv>site uv: <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span></span></div><span class=copyright-year>&copy;
2018 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>Yychi</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>