<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>析构函数与 override - 水阙</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Yychi"><meta name=description content=" virtual override final 上面三个关键字在继承体系中起着重要作用。virtual不用多说，声明虚函数必备的关键字。override和final是 C++11 中引入的，二者的作用其实更多是提醒开发者自己，
我正在重写一个虚函数 我正在重写一个虚函数，并且不希望再被派生类重写这个函数 "><meta name=keywords content="水阙,yychi"><meta name=generator content="Hugo 0.149.0 with theme even"><link rel=canonical href=https://guyueshui.github.io/post/override-destructor/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><link href=/sass/main.min.d70690ffa8f6f6f22c0e62cb71d66e67705dd030e9bcb57e066e4adb9823988c.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=/css/even-custom.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&family=Noto+Serif+SC:wght@400;500;700&display=swap" rel=stylesheet><meta property="og:url" content="https://guyueshui.github.io/post/override-destructor/"><meta property="og:site_name" content="水阙"><meta property="og:title" content="析构函数与 override"><meta property="og:description" content="virtual override final 上面三个关键字在继承体系中起着重要作用。virtual不用多说，声明虚函数必备的关键字。override和final是 C++11 中引入的，二者的作用其实更多是提醒开发者自己，
我正在重写一个虚函数 我正在重写一个虚函数，并且不希望再被派生类重写这个函数"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-09-03T21:40:03+08:00"><meta property="article:modified_time" content="2025-09-03T21:46:26+08:00"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Virtual"><meta property="article:tag" content="Override"><meta itemprop=name content="析构函数与 override"><meta itemprop=description content="virtual override final 上面三个关键字在继承体系中起着重要作用。virtual不用多说，声明虚函数必备的关键字。override和final是 C++11 中引入的，二者的作用其实更多是提醒开发者自己，
我正在重写一个虚函数 我正在重写一个虚函数，并且不希望再被派生类重写这个函数"><meta itemprop=datePublished content="2025-09-03T21:40:03+08:00"><meta itemprop=dateModified content="2025-09-03T21:46:26+08:00"><meta itemprop=wordCount content="1546"><meta itemprop=keywords content="Cpp,Virtual,Override"><meta name=twitter:card content="summary"><meta name=twitter:title content="析构函数与 override"><meta name=twitter:description content="virtual override final 上面三个关键字在继承体系中起着重要作用。virtual不用多说，声明虚函数必备的关键字。override和final是 C++11 中引入的，二者的作用其实更多是提醒开发者自己，
我正在重写一个虚函数 我正在重写一个虚函数，并且不希望再被派生类重写这个函数"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Yychi's Blog</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/search/><li class=mobile-menu-item>Search</li></a><a href=/links/><li class=mobile-menu-item>More</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/sketch/><li class=mobile-menu-item>Sketch</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Yychi's Blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/search/>Search</a></li><li class=menu-item><a class=menu-item-link href=/links/>More</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/sketch/>Sketch</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>析构函数与 override</h1><div class=post-meta><span class=post-time>September 3, 2025 </span><span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> times read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#用override修饰析构函数>用<code>override</code>修饰析构函数</a></li><li><a href=#为什么不用final修饰析构函数>为什么不用<code>final</code>修饰析构函数？</a></li><li><a href=#为什么不用virtual修饰析构函数>为什么不用<code>virtual</code>修饰析构函数？</a></li></ul></nav></div></div><div class=post-content><ul><li><code>virtual</code></li><li><code>override</code></li><li><code>final</code></li></ul><p>上面三个关键字在继承体系中起着重要作用。<code>virtual</code>不用多说，声明虚函数必备的关键字。<code>override</code>和<code>final</code>是 C++11 中引入的，二者的作用其实更多是提醒开发者自己，</p><ul><li>我正在重写一个虚函数</li><li>我正在重写一个虚函数，并且不希望再被派生类重写这个函数</li></ul><p>当然，<code>final</code>也可以用来修饰类，表示这是最后一次继承，即我这个类不能再被继承了。很形象，例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span> <span class=o>:</span> <span class=k>public</span> <span class=n>A</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>C</span> <span class=k>final</span> <span class=o>:</span> <span class=n>pubilc</span> <span class=n>B</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>D</span> <span class=o>:</span> <span class=k>public</span> <span class=n>C</span> <span class=p>{};</span> <span class=c1>// compile error!
</span></span></span></code></pre></td></tr></table></div></div><p>但除此之外，<code>final</code>和<code>override</code>对编译器而言，确实有助益。例如，</p><ul><li>如果你用<code>override</code>和<code>final</code>修饰一个函数，但基类没有这个函数，或者这个函数在基类没有被声明为虚函数，就会引发编译错误。当然，你可能只是手滑打错字了。但确实，编译错误帮你很快定位到这个问题。</li><li>如果你用<code>override</code>和<code>final</code>修饰一个函数，你就不必再用<code>virtual</code>修饰。因为这两个修饰已经暗示这个函数是虚函数。当然，如果基类中声明已经声明了<code>virtual</code>，无论你用不用这些修饰词，这个函数在派生类中都是虚函数。</li></ul><p>然而，有一个很纠结的问题。在多态体系中，基类的析构函数必须是[[../notes/cpp/多态#When should my destructor be <code>virtual</code>?|虚]]的。这就要问了，那对于派生类的析构函数，到底要不要声明为<code>virtual</code>，又或者用<code>override</code>或<code>final</code>修饰呢？这个问题很让人纠结，从下面这个 issue 出发，你可以看到大家的讨论</p><ul><li><a href=https://github.com/isocpp/CppCoreGuidelines/issues/721>C.128: Should destructors be marked &ldquo;override&rdquo;?</a></li></ul><h2 id=用override修饰析构函数>用<code>override</code>修饰析构函数</h2><p>不过我自己的建议是，<strong>对于派生类的析构函数，总是用<code>override</code>修饰</strong>。如果你这么做了，你将得到如下收益：</p><ol><li>编译器确保基类的析构函数是虚的，否则编译报错。真的有人会忘记将基类析构函数声明为虚的。</li><li>你可以直观看出，当前这个类有一个虚析构函数。</li></ol><p>同时，这也会因此困惑，</p><ol><li>析构函数可以被重写吗？你不敢确信，于是上网搜寻相关资料，发现并不能重写析构函数。过了一个月，你看到这段代码，又重演一遍上述剧情！</li></ol><p>确实，<em>用<code>override</code>修饰析构函数会造成困惑</em>！但是，它利大于弊。事实上，虚析构函数中的“虚”和普通的虚函数有着不一样的语义。对于普通成员函数，让他成为虚函数的目的是，我摆明了想在派生类中重写它，进而达到多态的效果。而析构函数的虚，是一种机制上的必须。当你用基类指针或引用使用[[../notes/cpp/多态#Dynamic binding|动态绑定]]时，对象的销毁依赖于虚析构函数。如果基类的析构函数非虚，那么对象销毁时，只会调用基类的析构函数，这可能造成派生类的资源没有释放，进而导致内存泄漏。而如果基类的析构函数是虚的，那么会调用到派生类的析构函数，而派生类的析构函数保证会调用基类的析构函数（C++标准保证），这样一来，就能保证资源以合理的顺序释放。</p><p>所以，用<code>override</code>修饰析构函数，并不是重写基类的析构函数（事实上我们也无法做到），而是在提醒编译器检查基类的虚构函数必须是虚的。</p><h2 id=为什么不用final修饰析构函数>为什么不用<code>final</code>修饰析构函数？</h2><p>事实上，<code>final</code>用来修饰函数，可以防止这个函数继续被派生类重写。但是，每个类都必须有析构函数！一旦析构函数被<code>final</code>修饰，那么这个类将无法再被继承。因为继承这个类，默认会带上生成析构函数，无论用不用这三个关键字修饰。然而，这个行为被基类的<code>final</code>阻止了，冲突了。这里，编译器认为是重写了被<code>final</code>修饰的函数，编译无法通过。</p><h2 id=为什么不用virtual修饰析构函数>为什么不用<code>virtual</code>修饰析构函数？</h2><p>可以，但没必要。因为如果基类析构函数已经是虚的，那么派生类析构函数自然而然也是虚的。用<code>virtual</code>修饰不会增加任何编译检查，因为<code>virtual</code>是声明虚函数的，对编译器没有任何提示作用。即便是基类没有的函数，派生类用<code>virtual</code>修饰的函数也会成为虚函数被进一步派生重写。</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Yychi</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>September 3, 2025
<a href=https://github.com/guyueshui/guyueshui.github.io/commit/7a379c7b1063ae252e6920c9a246dba6e568ac3a title="new article: override destructor">(7a379c7b)</a></span></p><p class=copyright-item><span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/cpp/>cpp</a>
<a href=/tags/virtual/>virtual</a>
<a href=/tags/override/>override</a></div><nav class=post-nav><a class=next href=/post/met-chilichill/><span class="next-text nav-default">遇见 ChiliChill</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://giscus.app/client.js data-repo=guyueshui/guyueshui.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkxNDI4MTY5NTE=" data-category=Ideas data-category-id=DIC_kwDOCIM2t84CW4nN data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:guyueshui002@gmail.com class="iconfont icon-email" title=email></a><a href=https://github.com/guyueshui class="iconfont icon-github" title=github></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer></div><span class=copyright-year>&copy;
2018 -
2025<span class=heart><i class="iconfont icon-heart"></i></span><span>Yychi</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>