<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Linux 的休眠 - 水阙</title>
<meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Yychi"><meta name=description content="先区分一下两个名词：睡眠（sleep）和休眠（hibernate）。
睡眠：将工作镜像写入内存（RAM），以便快速恢复。内存读写很快，所以睡眠的特点就是“睡得快”和“醒得快”。对于笔记本来说，合上盖子就睡了，打开盖子你的工作区间即刻就能恢复，很是方便。但是睡眠有一个缺点，就是要给内存供电，一旦断电，你的镜像数据就会丢失，工作区间将不复存在。当然这来自于内存的固有特点，建议百度 RAM。 休眠：将工作镜像写入硬盘（disk，ROM），这样你也可以恢复工作区间。只是睡下去和醒过来的时间比内存慢不少。但是，它有一个好处就是断电了也不会丢失数据。当你再次开机，系统就会从硬盘里面读取镜像，恢复你的工作区间。 "><meta name=keywords content="水阙,yychi"><meta name=generator content="Hugo 0.122.0 with theme even"><link rel=canonical href=https://guyueshui.github.io/post/linux-hibernate/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><link href=/sass/main.min.4db6eefa019323deeb0f96ac97b0195c6875d5cb6a98e30c1e245d54b43d54bc.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=/css/even-custom.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&family=Noto+Serif+SC:wght@400;500;700&display=swap" rel=stylesheet><meta property="og:title" content="Linux 的休眠"><meta property="og:description" content="先区分一下两个名词：睡眠（sleep）和休眠（hibernate）。

睡眠：将工作镜像写入内存（RAM），以便快速恢复。内存读写很快，所以睡眠的特点就是“睡得快”和“醒得快”。对于笔记本来说，合上盖子就睡了，打开盖子你的工作区间即刻就能恢复，很是方便。但是睡眠有一个缺点，就是要给内存供电，一旦断电，你的镜像数据就会丢失，工作区间将不复存在。当然这来自于内存的固有特点，建议百度 RAM。
休眠：将工作镜像写入硬盘（disk，ROM），这样你也可以恢复工作区间。只是睡下去和醒过来的时间比内存慢不少。但是，它有一个好处就是断电了也不会丢失数据。当你再次开机，系统就会从硬盘里面读取镜像，恢复你的工作区间。
"><meta property="og:type" content="article"><meta property="og:url" content="https://guyueshui.github.io/post/linux-hibernate/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-07-13T22:44:33+08:00"><meta property="article:modified_time" content="2024-01-27T23:24:11+08:00"><meta itemprop=name content="Linux 的休眠"><meta itemprop=description content="先区分一下两个名词：睡眠（sleep）和休眠（hibernate）。

睡眠：将工作镜像写入内存（RAM），以便快速恢复。内存读写很快，所以睡眠的特点就是“睡得快”和“醒得快”。对于笔记本来说，合上盖子就睡了，打开盖子你的工作区间即刻就能恢复，很是方便。但是睡眠有一个缺点，就是要给内存供电，一旦断电，你的镜像数据就会丢失，工作区间将不复存在。当然这来自于内存的固有特点，建议百度 RAM。
休眠：将工作镜像写入硬盘（disk，ROM），这样你也可以恢复工作区间。只是睡下去和醒过来的时间比内存慢不少。但是，它有一个好处就是断电了也不会丢失数据。当你再次开机，系统就会从硬盘里面读取镜像，恢复你的工作区间。
"><meta itemprop=datePublished content="2020-07-13T22:44:33+08:00"><meta itemprop=dateModified content="2024-01-27T23:24:11+08:00"><meta itemprop=wordCount content="6083"><meta itemprop=keywords content="hibernate,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux 的休眠"><meta name=twitter:description content="先区分一下两个名词：睡眠（sleep）和休眠（hibernate）。

睡眠：将工作镜像写入内存（RAM），以便快速恢复。内存读写很快，所以睡眠的特点就是“睡得快”和“醒得快”。对于笔记本来说，合上盖子就睡了，打开盖子你的工作区间即刻就能恢复，很是方便。但是睡眠有一个缺点，就是要给内存供电，一旦断电，你的镜像数据就会丢失，工作区间将不复存在。当然这来自于内存的固有特点，建议百度 RAM。
休眠：将工作镜像写入硬盘（disk，ROM），这样你也可以恢复工作区间。只是睡下去和醒过来的时间比内存慢不少。但是，它有一个好处就是断电了也不会丢失数据。当你再次开机，系统就会从硬盘里面读取镜像，恢复你的工作区间。
"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Yychi's Blog</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/search/><li class=mobile-menu-item>Search</li></a><a href=/links/><li class=mobile-menu-item>More</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/sketch/><li class=mobile-menu-item>Sketch</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Yychi's Blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/search/>Search</a></li><li class=menu-item><a class=menu-item-link href=/links/>More</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/sketch/>Sketch</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Linux 的休眠</h1><div class=post-meta><span class=post-time>July 13, 2020</span><div class=post-category><a href=/categories/linux/>linux</a></div><span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> times read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#确保-swap-分区足够大>确保 swap 分区足够大</a></li><li><a href=#查看fstab>查看<code>fstab</code></a></li><li><a href=#添加恢复分区的内核参数>添加恢复分区的内核参数</a></li><li><a href=#重新生成启动镜像>重新生成启动镜像</a></li><li><a href=#re-hibernation>Re: hibernation</a><ul><li><a href=#小尝试>小尝试</a></li></ul></li><li><a href=#bonus-使用-sleep-hook-在休眠时上锁>Bonus: 使用 sleep hook 在休眠时上锁</a></li><li><a href=#re2-hibernation>Re2: hibernation</a></li><li><a href=#references>References</a></li></ul></nav></div></div><div class=post-content><p>先区分一下两个名词：睡眠（sleep）和休眠（hibernate）。</p><ul><li>睡眠：将工作镜像写入内存（RAM），以便快速恢复。内存读写很快，所以睡眠的特点就是“睡得快”和“醒得快”。对于笔记本来说，合上盖子就睡了，打开盖子你的工作区间即刻就能恢复，很是方便。但是睡眠有一个缺点，就是要给内存供电，一旦断电，你的镜像数据就会丢失，工作区间将不复存在。当然这来自于内存的固有特点，建议百度 RAM。</li><li>休眠：将工作镜像写入硬盘（disk，ROM），这样你也可以恢复工作区间。只是睡下去和醒过来的时间比内存慢不少。但是，它有一个好处就是断电了也不会丢失数据。当你再次开机，系统就会从硬盘里面读取镜像，恢复你的工作区间。</li></ul><p>作为一个不求甚解的小白，我用 linux 这么些年，一直都只用过睡眠，每天晚上合上笔记本的盖子，第二天早上打开，工作区间即刻恢复，其实也是非常方便的，再也不用忍受关机开机的痛苦。这样一夜下来，大概要耗费 7-8% 的电量，还可以接受不是=。= 但是一旦你很长时间没用电脑，比如说放长假回家了，好久没碰电脑，那么笔记本的电池是会耗尽的，此时你的工作区间就丢了。（当然，这样的情况并不多见）</p><p>其实我以前也是鼓捣过 linux 休眠的，大概 3-4 年前，刚接触 linux 那会儿，在网上一通乱搜，一顿瞎试，未果。现在想来，失败的原因一是当时太菜，而是当时那个电脑太老旧了。据我所知，GPT 分区下搞休眠的坑是比较多的。现在的电脑大都是 EFI 分区，更加简单易用。</p><p>总体来说，休眠还是值得折腾的，因为支持断电！而且现在普遍使用固态硬盘，休眠和恢复的速度也并不是很慢。还有一个很重要的原因，笔记本电池的寿命很短，我的本子买了 3 年了，现在电池容量已经缩水 2/3 了！</p><p>好了，闲话少叙，进入正题。</p><h2 id=确保-swap-分区足够大>确保 swap 分区足够大</h2><p>拟使用 swap 分区作为写入镜像的目标分区。</p><p>一般建议 swap 分区为本机内存的一半，不过我认为有条件的还是将 swap 分区设置的略大于内存。此处，由于睡眠是将镜像写到内存，要确保 swap 分区能够容得下这个镜像，就必须将 swap 分区设置的大于内存。这并不是说 swap 小于内存就无法休眠了 <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，具体还是要看工作区间的镜像大小了。我现在的 swap 就只有本机内存的一半，但还是休眠成功了。</p><h2 id=查看fstab>查看<code>fstab</code></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ cat /etc/fstab
</span></span><span class=line><span class=cl><span class=c1># &lt;file system&gt;             &lt;mount point&gt;  &lt;type&gt;  &lt;options&gt;  &lt;dump&gt;  &lt;pass&gt;</span>
</span></span><span class=line><span class=cl><span class=c1># /dev/nvme0n1p5</span>
</span></span><span class=line><span class=cl><span class=nv>UUID</span><span class=o>=</span>547054ce-bb1b-40e4-a38d-24507d31d5ca   /           ext4        rw,relatime   <span class=m>0</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>UUID</span><span class=o>=</span>6E76-7D08          /boot/efi   vfat        rw,relatime,fmask<span class=o>=</span>0022,dmask<span class=o>=</span>0022,codepage<span class=o>=</span>437,iocharset<span class=o>=</span>iso8859-1,shortname<span class=o>=</span>mixed,utf8,errors<span class=o>=</span>remount-ro   <span class=m>0</span> <span class=m>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># /dev/nvme0n1p7</span>
</span></span><span class=line><span class=cl><span class=nv>UUID</span><span class=o>=</span>4227170f-0a4f-4a8e-a4fd-0d91f46f54af   none        swap        defaults,pri<span class=o>=</span>-0 <span class=m>0</span>
</span></span></code></pre></td></tr></table></div></div><p>系统启动时会读取该文件，按照其中的描述挂载对应的分区。默认生成的<code>fstab</code>中，swap 分区的类型是<code>swap</code>，将它改为<code>none</code>.</p><p>以下命令均可以查看分区信息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ lsblk
</span></span><span class=line><span class=cl>NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
</span></span><span class=line><span class=cl>sda           8:0    <span class=m>0</span> 223.6G  <span class=m>0</span> disk 
</span></span><span class=line><span class=cl>├─sda1        8:1    <span class=m>0</span>   110G  <span class=m>0</span> part /home/yychi/EXTRA
</span></span><span class=line><span class=cl>└─sda2        8:2    <span class=m>0</span> 113.6G  <span class=m>0</span> part 
</span></span><span class=line><span class=cl>nvme0n1     259:0    <span class=m>0</span> 238.5G  <span class=m>0</span> disk 
</span></span><span class=line><span class=cl>├─nvme0n1p1 259:1    <span class=m>0</span>   100M  <span class=m>0</span> part /boot/efi
</span></span><span class=line><span class=cl>├─nvme0n1p2 259:2    <span class=m>0</span>    16M  <span class=m>0</span> part 
</span></span><span class=line><span class=cl>├─nvme0n1p3 259:3    <span class=m>0</span> 119.5G  <span class=m>0</span> part 
</span></span><span class=line><span class=cl>├─nvme0n1p4 259:4    <span class=m>0</span>   798M  <span class=m>0</span> part 
</span></span><span class=line><span class=cl>├─nvme0n1p5 259:5    <span class=m>0</span>    65G  <span class=m>0</span> part /
</span></span><span class=line><span class=cl>├─nvme0n1p6 259:6    <span class=m>0</span>    49G  <span class=m>0</span> part /home
</span></span><span class=line><span class=cl>└─nvme0n1p7 259:7    <span class=m>0</span>   4.1G  <span class=m>0</span> part <span class=o>[</span>SWAP<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sudo blkid -o list
</span></span><span class=line><span class=cl>device           fs_type  label     mount point          UUID
</span></span><span class=line><span class=cl>----------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl>/dev/nvme0n1p1   vfat     ESP       /boot/efi            6E76-7D08
</span></span><span class=line><span class=cl>/dev/nvme0n1p2                     （未挂载）     
</span></span><span class=line><span class=cl>/dev/nvme0n1p3   ntfs     OS       （未挂载）     CADC772DDC7712C5
</span></span><span class=line><span class=cl>/dev/nvme0n1p4   ntfs              （未挂载）     624AD5CA4AD59B5D
</span></span><span class=line><span class=cl>/dev/nvme0n1p5   ext4     ROOT      /                    547054ce-bb1b-40e4-a38d-24507d31d5ca
</span></span><span class=line><span class=cl>/dev/nvme0n1p6   ext4     HOME      /home                1e23c2e3-6b73-465a-bd60-355b1bc4060b
</span></span><span class=line><span class=cl>/dev/nvme0n1p7   swap               <span class=o>[</span>SWAP<span class=o>]</span>               4227170f-0a4f-4a8e-a4fd-0d91f46f54af
</span></span><span class=line><span class=cl>/dev/sda1        ext4     DATA      /home/yychi/EXTRA    e66f87ee-33d8-4aaa-bff0-400df2276ef7
</span></span><span class=line><span class=cl>/dev/sda2        ntfs              （未挂载）     07B60D0A64472B59
</span></span></code></pre></td></tr></table></div></div><h2 id=添加恢复分区的内核参数>添加恢复分区的内核参数</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看当前内核启动命令</span>
</span></span><span class=line><span class=cl>$ cat /proc/cmdline
</span></span><span class=line><span class=cl><span class=se>\\</span>boot<span class=se>\v</span>mlinuz-linux ro <span class=nv>root</span><span class=o>=</span>/dev/nvme0n1p5 rw <span class=nv>resume</span><span class=o>=</span>/dev/nvme0n1p7 <span class=nv>initrd</span><span class=o>=</span>boot<span class=se>\i</span>nitramfs-linux.img
</span></span></code></pre></td></tr></table></div></div><p>可以看到，内核的启动参数中<code>resume=/dev/nvme0n1p7</code>这一项就指定了从该分区恢复，而该分区正是 swap 分区。</p><p>那么如何修改内核的命令行参数呢？找到你所使用的 boot manager（启动引导）程序，更改相应的配置。我使用的是 <a href=https://wiki.archlinux.org/index.php/REFInd>rEFInd</a>，需要做的更改为：</p><pre tabindex=0><code class=language-conf data-lang=conf># file: /boot/refind_linux.conf
&#34;Boot with standard options&#34;  &#34;ro root=/dev/nvme0n1p5 rw resume=/dev/nvme0n1p7&#34;
&#34;Boot to single-user mode&#34;    &#34;ro root=/dev/nvme0n1p5 single&#34;
</code></pre><p>直接在第一行最后的参数列表里加上<code>rw resume=/dev/nvme0n1p7</code>即可。Ubuntu 默认使用 grub 作为引导，这个网上教程更为详尽，此处就不再复制粘贴了。</p><h2 id=重新生成启动镜像>重新生成启动镜像</h2><p>作完更改之后，使用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ mkinitcpio -P
</span></span></code></pre></td></tr></table></div></div><p>重新生成启动镜像，使更改生效，最后重启系统。</p><p>重新进入系统之后，</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ cat /proc/cmdline
</span></span><span class=line><span class=cl><span class=se>\\</span>boot<span class=se>\v</span>mlinuz-linux ro <span class=nv>root</span><span class=o>=</span>/dev/nvme0n1p5 rw <span class=nv>resume</span><span class=o>=</span>/dev/nvme0n1p7 <span class=nv>initrd</span><span class=o>=</span>boot<span class=se>\i</span>nitramfs-linux.img
</span></span></code></pre></td></tr></table></div></div><p>如果参数列表里有<code>resume=/dev/nvme0n1p7</code>则说明设置成功。你可以打开一个程序，然后</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>systemctl hibernate
</span></span></code></pre></td></tr></table></div></div><p>令系统休眠，然后再按下电源开关，系统会自动恢复之前的工作环境。</p><p>今天先这样，写的不够详细，改日再完善吧～</p><hr><h2 id=re-hibernation>Re: hibernation</h2><p>万万没想到，今日（2022-05-04 00:14），我又为了休眠的事儿排查了两天之久。</p><p>自文章写完之后，一年多来，休眠一直工作的很好。直到这次五一，我准备解决一下之前一直悬而未决的<a href=../%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85linux#intel%E9%9B%86%E6%88%90%E6%98%BE%E5%8D%A1%E6%BB%9A%E5%8A%A8%E5%B1%8F%E5%B9%95%E5%87%BA%E7%8E%B0%E6%92%95%E8%A3%82%E7%8E%B0%E8%B1%A1>屏幕撕裂</a>问题。在此过程中，我尝试了启用笔记本的独显 NVIDIA Corporation GP108M [GeForce MX150], 也为此做了很多工作，甚至从 Nvidia 官网下载了驱动进行安装，就是这个过程，安装报错了，然后我打算放弃，执行了卸载，卸载也报错了。最后实现的效果，确实 X 和 picom 都运行在独显上了，但是进入 X 之后，屏幕一片漆黑。彼时夜已深，我就打算放弃了。直接电脑休眠，而我去睡觉了。</p><p>第二天打开电脑，才发现大事不妙。直接变成开机了，之前的工作状态并未还原。思来想去这期间干了什么呢？尝试安装独显驱动，解决屏幕撕裂，archlinux-keyring 损坏并重置，进行了系统全量更新（内核升级到 5.17.5-arch1-1）, 很难排查到底是什么原因导致的。只能打开 journal 细细排查可能的原因，</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ journalctl -b
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>5月 <span class=m>04</span> 00:01:11 MiBook-Air kernel: ACPI BIOS Error <span class=o>(</span>bug<span class=o>)</span>: Could not resolve symbol <span class=o>[</span><span class=se>\_</span>PR.PR00._CPC<span class=o>]</span>, AE_NOT_FOUND <span class=o>(</span>20211217/psargs-330<span class=o>)</span>
</span></span><span class=line><span class=cl>5月 <span class=m>04</span> 00:01:11 MiBook-Air kernel: ACPI Error: Aborting method <span class=se>\_</span>PR.PR01._CPC due to previous error <span class=o>(</span>AE_NOT_FOUND<span class=o>)</span> <span class=o>(</span>20211217/psparse-529<span class=o>)</span>
</span></span><span class=line><span class=cl>5月 <span class=m>04</span> 00:01:11 MiBook-Air kernel: ACPI BIOS Error <span class=o>(</span>bug<span class=o>)</span>: Could not resolve symbol <span class=o>[</span><span class=se>\_</span>PR.PR00._CPC<span class=o>]</span>, AE_NOT_FOUND <span class=o>(</span>20211217/psargs-330<span class=o>)</span>
</span></span><span class=line><span class=cl>5月 <span class=m>04</span> 00:01:11 MiBook-Air kernel: ACPI Error: Aborting method <span class=se>\_</span>PR.PR02._CPC due to previous error <span class=o>(</span>AE_NOT_FOUND<span class=o>)</span> <span class=o>(</span>20211217/psparse-529<span class=o>)</span>
</span></span><span class=line><span class=cl>5月 <span class=m>04</span> 00:01:11 MiBook-Air kernel: ACPI BIOS Error <span class=o>(</span>bug<span class=o>)</span>: Could not resolve symbol <span class=o>[</span><span class=se>\_</span>PR.PR00._CPC<span class=o>]</span>, AE_NOT_FOUND <span class=o>(</span>20211217/psargs-330<span class=o>)</span>
</span></span><span class=line><span class=cl>5月 <span class=m>04</span> 00:01:11 MiBook-Air kernel: ACPI Error: Aborting method <span class=se>\_</span>PR.PR03._CPC due to previous error <span class=o>(</span>AE_NOT_FOUND<span class=o>)</span> <span class=o>(</span>20211217/psparse-529<span class=o>)</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>第一个疑似的原因就是这个，但经过一番搜索，他也仅仅是个内核的 bug<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，并不能证明他和休眠失败有直接关系。</p><p>接着我直接找到这段时间的系统日志，一行一行的查看，凡是有疑似的都搜索之，未果。期间我发现，之前正常休眠恢复的日志序列大概是下面这个样子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>4月 <span class=m>28</span> 23:59:06 MiBook-Air systemd-sleep<span class=o>[</span>515989<span class=o>]</span>: Entering sleep state <span class=s1>&#39;hibernate&#39;</span>...
</span></span><span class=line><span class=cl>4月 <span class=m>28</span> 23:59:06 MiBook-Air kernel: PM: hibernation: hibernation entry
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: Filesystems sync: 0.004 seconds
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: Freezing user space processes ... <span class=o>(</span>elapsed 0.001 seconds<span class=o>)</span> <span class=k>done</span>.
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: OOM killer disabled.
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: <span class=o>[</span>mem 0x00000000-0x00000fff<span class=o>]</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: <span class=o>[</span>mem 0x00058000-0x00058fff<span class=o>]</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: <span class=o>[</span>mem 0x0009e000-0x000fffff<span class=o>]</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: <span class=o>[</span>mem 0x71d1c000-0x71d1cfff<span class=o>]</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: <span class=o>[</span>mem 0x71d48000-0x71d48fff<span class=o>]</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: <span class=o>[</span>mem 0x725dc000-0x725dcfff<span class=o>]</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: <span class=o>[</span>mem 0x725ec000-0x725ecfff<span class=o>]</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: <span class=o>[</span>mem 0x7312f000-0x73130fff<span class=o>]</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: <span class=o>[</span>mem 0x75388000-0x75c87fff<span class=o>]</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: <span class=o>[</span>mem 0x7c026000-0x7c02bfff<span class=o>]</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: <span class=o>[</span>mem 0x8be9e000-0x8cffdfff<span class=o>]</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: <span class=o>[</span>mem 0x8cfff000-0xffffffff<span class=o>]</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Basic memory bitmaps created
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Preallocating image memory
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Allocated <span class=m>676076</span> pages <span class=k>for</span> snapshot
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: PM: hibernation: Allocated <span class=m>2704304</span> kbytes in 0.38 seconds <span class=o>(</span>7116.58 MB/s<span class=o>)</span>
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: Freezing remaining freezable tasks ... <span class=o>(</span>elapsed 0.001 seconds<span class=o>)</span> <span class=k>done</span>.
</span></span><span class=line><span class=cl>4月 <span class=m>29</span> 19:48:53 MiBook-Air kernel: printk: Suspending console<span class=o>(</span>s<span class=o>)</span> <span class=o>(</span>use no_console_suspend to debug<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到，日志从 4 月 28 日 23:59:06 一下子跳到 4 月 29 日 19:48:53，也就是说我在 28 日晚上发起了休眠，在 29 日晚上再度打开电脑，成功恢复了工作区。</p><p>而在休眠失败后日志是下面这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>5月 <span class=m>01</span> 02:13:41 MiBook-Air systemd<span class=o>[</span>1<span class=o>]</span>: Reached target Sleep.
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 02:13:41 MiBook-Air systemd<span class=o>[</span>1<span class=o>]</span>: Starting Hibernate...
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 02:13:41 MiBook-Air kernel: PM: Image not found <span class=o>(</span>code -16<span class=o>)</span>
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 02:13:41 MiBook-Air dhcpcd<span class=o>[</span>463<span class=o>]</span>: wlp2s0: old hardware address: f8:63:3f:4d:a1:8e
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 02:13:41 MiBook-Air dhcpcd<span class=o>[</span>463<span class=o>]</span>: wlp2s0: new hardware address: 66:34:25:c7:18:31
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 02:13:41 MiBook-Air systemd-sleep<span class=o>[</span>13740<span class=o>]</span>: Entering sleep state <span class=s1>&#39;hibernate&#39;</span>...
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 02:13:41 MiBook-Air dhcpcd<span class=o>[</span>463<span class=o>]</span>: wlp2s0: old hardware address: 66:34:25:c7:18:31
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 02:13:41 MiBook-Air dhcpcd<span class=o>[</span>463<span class=o>]</span>: wlp2s0: new hardware address: f8:63:3f:4d:a1:8e
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 02:13:41 MiBook-Air kernel: PM: hibernation: hibernation entry
</span></span><span class=line><span class=cl>-- Boot a60e8709e7b945abbcdb13a477011e7b --
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 18:43:13 MiBook-Air kernel: Linux version 5.17.5-arch1-1 <span class=o>(</span>linux@archlinux<span class=o>)</span> <span class=o>(</span>gcc <span class=o>(</span>GCC<span class=o>)</span> 11.2.0, GNU ld <span class=o>(</span>GNU Binutils<span class=o>)</span> 2.38<span class=o>)</span> <span class=c1>#1 SMP PREEMPT Wed, 27 Apr 2022 20:56:11 +0000</span>
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 18:43:13 MiBook-Air kernel: Command line: ro <span class=nv>root</span><span class=o>=</span>/dev/nvme0n1p5 rw <span class=nv>resume</span><span class=o>=</span>/dev/nvme0n1p7 <span class=nv>initrd</span><span class=o>=</span>boot<span class=se>\i</span>nitramfs-linux.img
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 18:43:13 MiBook-Air kernel: x86/fpu: Supporting XSAVE feature 0x001: <span class=s1>&#39;x87 floating point registers&#39;</span>
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 18:43:13 MiBook-Air kernel: x86/fpu: Supporting XSAVE feature 0x002: <span class=s1>&#39;SSE registers&#39;</span>
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 18:43:13 MiBook-Air kernel: x86/fpu: Supporting XSAVE feature 0x004: <span class=s1>&#39;AVX registers&#39;</span>
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 18:43:13 MiBook-Air kernel: x86/fpu: Supporting XSAVE feature 0x008: <span class=s1>&#39;MPX bounds registers&#39;</span>
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 18:43:13 MiBook-Air kernel: x86/fpu: Supporting XSAVE feature 0x010: <span class=s1>&#39;MPX CSR&#39;</span>
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 18:43:13 MiBook-Air kernel: x86/fpu: xstate_offset<span class=o>[</span>2<span class=o>]</span>:  576, xstate_sizes<span class=o>[</span>2<span class=o>]</span>:  <span class=m>256</span>
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 18:43:13 MiBook-Air kernel: x86/fpu: xstate_offset<span class=o>[</span>3<span class=o>]</span>:  832, xstate_sizes<span class=o>[</span>3<span class=o>]</span>:   <span class=m>64</span>
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 18:43:13 MiBook-Air kernel: x86/fpu: xstate_offset<span class=o>[</span>4<span class=o>]</span>:  896, xstate_sizes<span class=o>[</span>4<span class=o>]</span>:   <span class=m>64</span>
</span></span><span class=line><span class=cl>5月 <span class=m>01</span> 18:43:13 MiBook-Air kernel: x86/fpu: Enabled xstate features 0x1f, context size is <span class=m>960</span> bytes, using <span class=s1>&#39;compacted&#39;</span> format.
</span></span></code></pre></td></tr></table></div></div><p>同样在时间跳跃节点看，此前的日志看起来是休眠成功了，此后竟然直接走了 boot 流程！因此我猜测肯定是恢复（resume）过程出了问题，休眠（hibernation）是正常工作的。</p><p>我尝试过将内涵参数中的<code>resume=/dev/xxx</code>改为<code>resume=UUID=xxx-xxxx-xx</code>，也还是不行。最让人无奈的是，到现在没有发现问题所在，一直在摸黑尝试。</p><p>后来看到两篇文章（其实就是 Ref2 中提及的）:</p><ol><li><a href=https://www.kernel.org/doc/Documentation/power/basic-pm-debugging.txt>Debugging hibernation and suspend</a></li><li><a href=https://01.org/blogs/rzhang/2015/best-practice-debug-linux-suspend/hibernate-issues>BEST PRACTICE TO DEBUG LINUX* SUSPEND/HIBERNATE ISSUES</a></li></ol><p>开始对休眠过程进行更具针对性的 debug，推荐从第一篇文章开始。经过一番 debug，发现我的休眠功能确实没啥问题，恢复功能也没问题，即第一篇文章提到的：</p><blockquote><p>That test can be used to check if failures to resume from hibernation are
related to bad interactions with the platform firmware. That is, if the above
works every time, but resume from actual hibernation does not work or is
unreliable, the platform firmware may be responsible for the failures.</p></blockquote><p>但即便知道了可能是硬件问题，我也看不出来是哪里的问题啊（太菜了 orz）。无奈之下尝试第二篇的 debug 方法，在鼓捣了一对内核参数之后，日志确实更详尽了，但其中暴露出的问题，google 都没有搜索结果。我哪看得懂啊？最后带着快要放弃的心情，再次翻开了 ArchWiki（再次高呼，ArchWiki YYDS！）上的一篇文章（Ref7）, 其中提到：</p><blockquote><p>The kernel parameters will only take effect after rebooting. To be able to hibernate right away, obtain the volume&rsquo;s major and minor device numbers from <a href=https://wiki.archlinux.org/title/Lsblk title=Lsblk>lsblk</a> and echo them in format <code>*major*:*minor*</code> to <code>/sys/power/resume</code>. If using a swap file, additionally echo the resume offset to <code>/sys/power/resume_offset</code>.<a href=https://www.kernel.org/doc/html/latest/power/swsusp.html>[2]</a></p></blockquote><p>我就试探性的照做了，</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>yychi@~&gt; lsblk
</span></span><span class=line><span class=cl>NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
</span></span><span class=line><span class=cl>sda           8:0    <span class=m>0</span> 223.6G  <span class=m>0</span> disk 
</span></span><span class=line><span class=cl>├─sda1        8:1    <span class=m>0</span>   110G  <span class=m>0</span> part /home/yychi/EXTRA
</span></span><span class=line><span class=cl>└─sda2        8:2    <span class=m>0</span> 113.6G  <span class=m>0</span> part 
</span></span><span class=line><span class=cl>nvme0n1     259:0    <span class=m>0</span> 238.5G  <span class=m>0</span> disk 
</span></span><span class=line><span class=cl>├─nvme0n1p1 259:1    <span class=m>0</span>   100M  <span class=m>0</span> part /boot/efi
</span></span><span class=line><span class=cl>├─nvme0n1p2 259:2    <span class=m>0</span>    16M  <span class=m>0</span> part 
</span></span><span class=line><span class=cl>├─nvme0n1p3 259:3    <span class=m>0</span> 119.5G  <span class=m>0</span> part 
</span></span><span class=line><span class=cl>├─nvme0n1p4 259:4    <span class=m>0</span>   798M  <span class=m>0</span> part 
</span></span><span class=line><span class=cl>├─nvme0n1p5 259:5    <span class=m>0</span>    65G  <span class=m>0</span> part /
</span></span><span class=line><span class=cl>├─nvme0n1p6 259:6    <span class=m>0</span>    49G  <span class=m>0</span> part /home
</span></span><span class=line><span class=cl>└─nvme0n1p7 259:7    <span class=m>0</span>   4.1G  <span class=m>0</span> part <span class=o>[</span>SWAP<span class=o>]</span>
</span></span><span class=line><span class=cl>yychi@~&gt; <span class=nb>echo</span> 259:7 &gt; /sys/power/resume
</span></span></code></pre></td></tr></table></div></div><p>以及 <a href=https://wiki.archlinux.org/title/Power_management/Suspend_and_hibernate#Configure_the_initramfs>此处</a> 提及</p><ul><li>When an <a href=https://wiki.archlinux.org/title/Initramfs title=Initramfs>initramfs</a> with the <code>base</code> hook is used, which is the default, the <code>resume</code> hook is required in <code>/etc/mkinitcpio.conf</code>. Whether by label or by UUID, the swap partition is referred to with a udev device node, so the <code>resume</code> hook must go <em>after</em> the <code>udev</code> hook. This example was made starting from the default hook configuration:</li></ul><pre tabindex=0><code>HOOKS=(base udev autodetect keyboard modconf block filesystems **resume** fsck)
</code></pre><p>Remember to <a href=https://wiki.archlinux.org/title/Regenerate_the_initramfs title="Regenerate the initramfs">regenerate the initramfs</a> for these changes to take effect.</p><ul><li>When an initramfs with the <code>systemd</code> hook is used, a resume mechanism is already provided, and no further hooks need to be added.</li></ul><p>总结一下：就是往<code>/sys/power/resume</code>里写入正确的数值，以及在<code>/etc/mkinitcpio.conf</code>里加上<code>resume</code>hook，重新<code>mkinitcpio -P</code>，然后<strong>休眠恢复就成功</strong>了！</p><h3 id=小尝试>小尝试</h3><p>经过尝试，把<code>/etc/mkinitcpio.conf</code>中 HOOKS 中的 resume 去掉，再<code>mkinitcpio -P</code>，再次休眠后就无法恢复，直接走 boot 流程了。并且启动后<code>/sys/power/resume</code>的值丢失了（恢复默认）:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ cat /sys/power/resume
</span></span><span class=line><span class=cl>0:0
</span></span></code></pre></td></tr></table></div></div><p>而将 HOOKS 中的 resume 加上之后，再<code>mkinitcpio -P</code>生效之，重启后</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ cat /sys/power/resume
</span></span><span class=line><span class=cl>259:7
</span></span></code></pre></td></tr></table></div></div><p>有值了，而且休眠之后可以成功恢复。</p><p>看起来就是这里的原因了，恢复的时候由于找不到 swap 分区导致 fallback 到 boot 流程，而 resume hook 就是起到告诉 kernel swap 分区的标识，因此才能成功恢复。但有一个问题，之前我没有动过这些，也能休眠并恢复成功。从 <a href=https://wiki.archlinux.org/title/Power_management/Suspend_and_hibernate#Configure_the_initramfs>ArchWiki 上的描述</a> 来看，HOOKS 中使用了<code>systemd</code>的，不需要加<code>resume</code>；使用了<code>base</code>的，需要加<code>resume</code>。看来是某些操作改了我的<code>/etc/mkinitcpio.conf</code>？</p><h2 id=bonus-使用-sleep-hook-在休眠时上锁>Bonus: 使用 sleep hook 在休眠时上锁</h2><p>此前使用休眠的场景是这样的：terminal 里面敲<code>systemctl hibernate</code>，等待休眠成功，合上盖子，time flies，打开盖子，启动电源，恢复工作区。这个过程没有涉及到用户验证，所以如果此间别人拿了你的电脑，自然能一窥你的裙底风光。所以，合理的做法应该是休眠时顺便锁个屏。</p><p>其实 ArchWiki 也有提到<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>，利用<code>systemd</code>管理的 service 可以做到。具体说来，可以创建如下文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=c1># /etc/systemd/system/suspend@.service</span>
</span></span><span class=line><span class=cl><span class=c1># see: https://wiki.archlinux.org/title/Power_management#Sleep_hooks</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Unit]</span>
</span></span><span class=line><span class=cl><span class=na>Description</span><span class=o>=</span><span class=s>User suspend actions</span>
</span></span><span class=line><span class=cl><span class=na>Before</span><span class=o>=</span><span class=s>sleep.target</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Service]</span>
</span></span><span class=line><span class=cl><span class=na>User</span><span class=o>=</span><span class=s>%I</span>
</span></span><span class=line><span class=cl><span class=na>Type</span><span class=o>=</span><span class=s>simple</span>
</span></span><span class=line><span class=cl><span class=na>Environment</span><span class=o>=</span><span class=s>DISPLAY=:0</span>
</span></span><span class=line><span class=cl><span class=na>ExecStart</span><span class=o>=</span><span class=s>/usr/bin/slock</span>
</span></span><span class=line><span class=cl><span class=na>ExecStartPost</span><span class=o>=</span><span class=s>/usr/bin/sleep 1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Install]</span>
</span></span><span class=line><span class=cl><span class=na>WantedBy</span><span class=o>=</span><span class=s>sleep.target</span>
</span></span></code></pre></td></tr></table></div></div><p>形如<code>xxx@.service</code>的文件称为 template service，它可以带一个参数拼接成一个 instantiated service 文件，比如<code>xxx@username.service</code>，具体可参考<code>man 5 systemd.service</code>. 上述我创建了一个<code>suspend@.service</code>，然后我们启用（enable on boot）一个 instantiated service</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ systemctl <span class=nb>enable</span> suspend@yychi.service
</span></span></code></pre></td></tr></table></div></div><p>接着 reload 一下使其立刻生效，</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ systemctl daemon-reload
</span></span></code></pre></td></tr></table></div></div><p>然后调用<code>systemctl hibernate</code>看看效果，果然在挂起、恢复之后，出现了锁屏界面<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>。</p><p>热心观众可能发现，上述 service 对<code>systemctl suspend</code>同样生效，其原因是 suspend 和 hibernate 同样都在<code>sleep.target</code>之后，而我们的 service 定义了<code>Before=sleep.target</code>，说明<code>suspend@yychi.service</code>要在<code>sleep.target</code>之前执行。因此无论是 sleep 还是 hibernate 都能用上。印证如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>yychi@/etc/systemd/system&gt; systemctl cat suspend.target                                21:15
</span></span><span class=line><span class=cl><span class=o>[</span>Unit<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Description</span><span class=o>=</span>Suspend
</span></span><span class=line><span class=cl><span class=nv>Documentation</span><span class=o>=</span>man:systemd.special<span class=o>(</span>7<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nv>DefaultDependencies</span><span class=o>=</span>no
</span></span><span class=line><span class=cl><span class=nv>Requires</span><span class=o>=</span>systemd-suspend.service
</span></span><span class=line><span class=cl><span class=nv>After</span><span class=o>=</span>systemd-suspend.service
</span></span><span class=line><span class=cl><span class=nv>StopWhenUnneeded</span><span class=o>=</span>yes
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>yychi@/etc/systemd/system&gt; systemctl cat systemd-suspend.service                       21:37
</span></span><span class=line><span class=cl><span class=o>[</span>Unit<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Description</span><span class=o>=</span>System Suspend
</span></span><span class=line><span class=cl><span class=nv>Documentation</span><span class=o>=</span>man:systemd-suspend.service<span class=o>(</span>8<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nv>DefaultDependencies</span><span class=o>=</span>no
</span></span><span class=line><span class=cl><span class=nv>Requires</span><span class=o>=</span>sleep.target
</span></span><span class=line><span class=cl><span class=nv>After</span><span class=o>=</span>sleep.target  <span class=c1># 注意此处</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Service<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Type</span><span class=o>=</span>oneshot
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>/usr/lib/systemd/systemd-sleep <span class=nb>suspend</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>yychi@/etc/systemd/system&gt; systemctl cat hibernate.target                              21:37
</span></span><span class=line><span class=cl><span class=o>[</span>Unit<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Description</span><span class=o>=</span>System Hibernation
</span></span><span class=line><span class=cl><span class=nv>Documentation</span><span class=o>=</span>man:systemd.special<span class=o>(</span>7<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nv>DefaultDependencies</span><span class=o>=</span>no
</span></span><span class=line><span class=cl><span class=nv>Requires</span><span class=o>=</span>systemd-hibernate.service
</span></span><span class=line><span class=cl><span class=nv>After</span><span class=o>=</span>systemd-hibernate.service
</span></span><span class=line><span class=cl><span class=nv>StopWhenUnneeded</span><span class=o>=</span>yes
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>yychi@/etc/systemd/system&gt; systemctl cat systemd-hibernate.service                     21:38
</span></span><span class=line><span class=cl><span class=c1># /usr/lib/systemd/system/systemd-hibernate.service</span>
</span></span><span class=line><span class=cl><span class=o>[</span>Unit<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Description</span><span class=o>=</span>Hibernate
</span></span><span class=line><span class=cl><span class=nv>Documentation</span><span class=o>=</span>man:systemd-hibernate.service<span class=o>(</span>8<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nv>DefaultDependencies</span><span class=o>=</span>no
</span></span><span class=line><span class=cl><span class=nv>Requires</span><span class=o>=</span>sleep.target
</span></span><span class=line><span class=cl><span class=nv>After</span><span class=o>=</span>sleep.target  <span class=c1># 注意此处</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Service<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Type</span><span class=o>=</span>oneshot
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>/usr/lib/systemd/systemd-sleep hibernate
</span></span></code></pre></td></tr></table></div></div><h2 id=re2-hibernation>Re2: hibernation</h2><p>今天（2024-01-27），又出现了休眠问题，好在有了之前的经历，2H 就定位出来了。</p><p>休眠失败，首先看 journal：</p><pre tabindex=0><code>1月 27 19:32:12 MiBook-Air systemd[1]: Started User suspend actions.
1月 27 19:32:12 MiBook-Air systemd[1]: Reached target Sleep.
1月 27 19:32:12 MiBook-Air systemd[1]: Starting System Hibernate...
1月 27 19:32:12 MiBook-Air systemd-sleep[11138]: Performing sleep operation &#39;hibernate&#39;...
1月 27 19:32:12 MiBook-Air kernel: PM: hibernation: hibernation entry
1月 27 19:32:32 MiBook-Air kernel: Filesystems sync: 0.022 seconds
1月 27 19:32:32 MiBook-Air kernel: Freezing user space processes
1月 27 19:32:32 MiBook-Air kernel: Freezing user space processes completed (elapsed 0.003 seconds)
1月 27 19:32:32 MiBook-Air kernel: OOM killer disabled.
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x00000000-0x00000fff]
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x00058000-0x00058fff]
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x0009e000-0x000fffff]
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x71c54000-0x71c54fff]
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x71c80000-0x71c80fff]
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x725d9000-0x725d9fff]
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x725e9000-0x725e9fff]
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x7312f000-0x73130fff]
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x75388000-0x75c87fff]
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x7bff2000-0x7bff7fff]
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x8be9e000-0x8cffdfff]
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x8cfff000-0xffffffff]
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Basic memory bitmaps created
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Preallocating image memory
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Allocated 791290 pages for snapshot
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: Allocated 3165160 kbytes in 1.56 seconds (2028.94 MB/s)
1月 27 19:32:32 MiBook-Air kernel: Freezing remaining freezable tasks
1月 27 19:32:32 MiBook-Air kernel: Freezing remaining freezable tasks completed (elapsed 0.001 seconds)
1月 27 19:32:32 MiBook-Air kernel: printk: Suspending console(s) (use no_console_suspend to debug)
1月 27 19:32:32 MiBook-Air kernel: ata1.00: Entering standby power mode
1月 27 19:32:32 MiBook-Air kernel: nouveau 0000:01:00.0: DRM: failed to idle channel 1 [DRM]
1月 27 19:32:32 MiBook-Air kernel: nouveau 0000:01:00.0: PM: pci_pm_freeze(): nouveau_pmops_freeze+0x0/0x20 [nouveau] returns -16
1月 27 19:32:32 MiBook-Air kernel: nouveau 0000:01:00.0: PM: dpm_run_callback(): pci_pm_freeze+0x0/0xc0 returns -16
1月 27 19:32:32 MiBook-Air kernel: nouveau 0000:01:00.0: PM: failed to freeze async: error -16
1月 27 19:32:32 MiBook-Air kernel: usb usb1: root hub lost power or was reset
1月 27 19:32:32 MiBook-Air kernel: usb usb2: root hub lost power or was reset
1月 27 19:32:32 MiBook-Air kernel: nvme nvme0: 4/0/0 default/read/poll queues
1月 27 19:32:32 MiBook-Air kernel: usb 1-1: reset full-speed USB device number 2 using xhci_hcd

...

1月 27 19:32:32 MiBook-Air systemd-sleep[11138]: Failed to put system to sleep. System resumed again: Device or resource busy
1月 27 19:32:32 MiBook-Air kernel: PM: hibernation: hibernation exit
...
1月 27 19:32:32 MiBook-Air systemd[1]: systemd-hibernate.service: Main process exited, code=exited, status=1/FAILURE
1月 27 19:32:32 MiBook-Air systemd[1]: systemd-hibernate.service: Failed with result &#39;exit-code&#39;.
1月 27 19:32:32 MiBook-Air systemd[1]: Failed to start System Hibernate.
1月 27 19:32:32 MiBook-Air systemd[1]: Dependency failed for System Hibernation.
1月 27 19:32:32 MiBook-Air systemd[1]: hibernate.target: Job hibernate.target/start failed with result &#39;dependency&#39;.
1月 27 19:32:32 MiBook-Air systemd[1]: systemd-hibernate.service: Consumed 1.750s CPU time.
1月 27 19:32:32 MiBook-Air systemd[1]: Stopped target Sleep.
1月 27 19:32:32 MiBook-Air systemd-logind[379]: Operation &#39;sleep&#39; finished.
</code></pre><p>可以看到，日志里清晰可见说了休眠失败，resume 到休眠前的状态。而往上溯源可以看到，失败原因是</p><pre tabindex=0><code>1月 27 19:32:32 MiBook-Air kernel: nouveau 0000:01:00.0: DRM: failed to idle channel 1 [DRM]
1月 27 19:32:32 MiBook-Air kernel: nouveau 0000:01:00.0: PM: pci_pm_freeze(): nouveau_pmops_freeze+0x0/0x20 [nouveau] returns -16
1月 27 19:32:32 MiBook-Air kernel: nouveau 0000:01:00.0: PM: dpm_run_callback(): pci_pm_freeze+0x0/0xc0 returns -16
1月 27 19:32:32 MiBook-Air kernel: nouveau 0000:01:00.0: PM: failed to freeze async: error -16
</code></pre><p>根据这个线索搜索，最后发现直接 block nouveau 即可<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>，即禁用 nvidia 的显卡。因为我的笔记本有两块显卡，一个 intel 的核显，一个 nvidia 的集显。在 linux 环境下为这集显我没少踩坑。</p><pre tabindex=0><code>yychi@~&gt; lspci -k | grep -A 2 -E &#34;(VGA|3D)&#34;
00:02.0 VGA compatible controller: Intel Corporation HD Graphics 620 (rev 02)
    Subsystem: Xiaomi HD Graphics 620
    Kernel driver in use: i915
--
01:00.0 3D controller: NVIDIA Corporation GP108M [GeForce MX150] (rev a1)
    Subsystem: Xiaomi GP108M [GeForce MX150]
    Kernel modules: nouveau
</code></pre><p>解决方法：直接加个文件<code>/etc/modprobe.d/nouveau_blacklist.conf</code>，重启后即可正常休眠。</p><pre tabindex=0><code>ychi@~&gt; cat /etc/modprobe.d/nouveau_blacklist.conf
# block nouveau, otherwise hibernation will not work.
# yychi, 2024.1
blacklist nouveau
</code></pre><p>关于休眠，暂时探索至此&mldr;</p><h2 id=references>References</h2><ol><li><a href=https://superuser.com/questions/1124966/is-hybrid-sleep-the-same-in-linux-as-in-windows>Is Hybrid Sleep the same in Linux as in Windows?</a></li><li><a href=https://askubuntu.com/questions/768136/how-can-i-hibernate-on-ubuntu-16-04/821122#821122>How can I hibernate on Ubuntu 16.04?</a></li><li><a href=https://askubuntu.com/questions/145443/how-do-i-use-pm-suspend-hybrid-by-default-instead-of-pm-suspend/781957#781957>How do I use pm-suspend-hybrid by default instead of pm-suspend?</a></li><li><a href=https://wiki.archlinux.org/index.php/kernel_parameters#rEFInd>Kernel parameters</a></li><li><a href=https://forum.manjaro.org/t/error-resume-no-device-specified-for-hibernation/119074>Error resume: no device specified for hibernation</a></li><li><a href="https://bbs.archlinux.org/viewtopic.php?id=156497">Hibernation: Resume Can&rsquo;t Find Swap</a></li><li><a href=https://wiki.archlinux.org/title/Power_management/Suspend_and_hibernate>Power management/Suspend and hibernate - ArchWiki</a></li></ol><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>See <a href=https://wiki.archlinux.org/index.php/Power_management/Suspend_and_hibernate#About_swap_partition.2Ffile_size>Arch wiki</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://github.com/intel/linux-intel-lts/issues/22>ACPI BIOS Error (bug)</a>: Could not resolve symbol [\_PR.PR00._CPC]&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://wiki.archlinux.org/title/Power_management#Sleep_hooks>Suspend/resume service files</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://wiki.archlinux.org/title/Slock#Lock_on_suspend>Slock - lock on suspend</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>此处我用的是 <a href=https://wiki.archlinux.org/title/Slock#Lock_on_suspend>slock</a>，X 下一个非常简单轻巧的锁屏工具。简单到什么程度呢？它连配置文件都没有，想要自定义，必须改<code>config.h</code>然后重新编译！&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>参考帖子：<a href="https://bbs.archlinux.org/viewtopic.php?id=248019">[Solved]Issues with mesa</a>.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Yychi</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>January 27, 2024</span></p><p class=copyright-item><span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/hibernate/>hibernate</a></div><nav class=post-nav><a class=prev href=/post/python-iterables/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Python Iterables</span>
<span class="prev-text nav-mobile">Prev</span>
</a><a class=next href=/post/tex-sty-basic/><span class="next-text nav-default">一个 really simple 的 LaTeX 宏包</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://giscus.app/client.js data-repo=guyueshui/guyueshui.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkxNDI4MTY5NTE=" data-category=Ideas data-category-id=DIC_kwDOCIM2t84CW4nN data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:guyueshui002@gmail.com class="iconfont icon-email" title=email></a><a href=https://github.com/guyueshui class="iconfont icon-github" title=github></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer></div><span class=copyright-year>&copy;
2018 -
2024<span class=heart><i class="iconfont icon-heart"></i></span><span>Yychi</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>